
\documentclass[twoside]{article}
\usepackage[colorlinks,linkcolor=black]{hyperref}
\usepackage{xeCJK}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{amsmath, amsthm}
\usepackage{listings,xcolor}
\usepackage{geometry}
\usepackage{fontspec}
\setsansfont{Monaco}
\setmonofont[Mapping={}]{Monaco}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\geometry{left=2.5cm,right=2.5cm,top=2.5cm,bottom=2.5cm}
\lstset{
    language    = c++,
    breaklines  = true,
    captionpos  = b,
    tabsize     = 4,
    numbers     = left,
    columns     = fullflexible,
    keepspaces  = true,
    commentstyle = \color[RGB]{0,128,0},
    keywordstyle = \color[RGB]{0,0,255},
    basicstyle   = \small\ttfamily,
    rulesepcolor = \color{red!20!green!20!blue!20},
    showstringspaces = false,
}
\title{ACM Template}
\author{Team Untitled}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[C]{ACM Template, Team Untitled}
\begin{document}\small
\begin{titlepage}
\begin{center}
\vspace*{0.5cm}\includegraphics[width=0.75\textwidth]{logo.jpg} \\ [2cm]
\HRule \\ [1cm]
\textbf{\Huge{ACM Template}} \\ [0.5cm]
\HRule \\ [4cm]
\textbf{\Huge{Shanghai University}} \\ [1cm]
\LARGE{Team Untitled}
\vfill
\Large{\today}
\end{center}
\clearpage
\end{titlepage}
\tableofcontents\clearpage
\pagestyle{fancy}
\lfoot{}
\cfoot{\thepage}\rfoot{}
\setcounter{section}{-1}
\setcounter{page}{1}
\clearpage\section{Header}
\begin{lstlisting}
#include <bits/stdc++.h> // #include <algorithm>
using namespace std;
#define clr(a, x) memset(a, x, sizeof(a))
#define pb(x) push_back(x)
#define X first
#define Y second
typedef pair<int, int> PII;
typedef vector<int> VI;
typedef long long ll;
const int INF = 0x3f3f3f3f;
const int minINF = 0xc0c0c0c0;
const int mod = 1e9 + 7;
const double eps = 1e-6; //若题目要求保留到小数点后6位，则为1e-7
const double PI = acos(-1.0);
const double E = exp(1);

//关闭同步/解除绑定
ios_base::sync_with_stdio(false);
cin.tie(0);

// 字符串转数字要考虑负号
\end{lstlisting}
\clearpage\section{Math}
\subsection{Prime}
\subsubsection{Eular Sieve}
原理：对于任意合数，必定可以有最小质因子乘以最大因子的分解方式 $O(n)$
因此，对于每个合数，只要用最大因子筛一遍，枚举时只要枚举最小质因子即可。
因为一般有 $prime[i]*prime[i]<=n$ ，所以筛选范围为 $\sqrt{n}$
1e7--665000   1e6--80000   1e5--1e4
\begin{lstlisting}
int prime[cnt]; //prime[0]储存素数的个数，素数下标从1开始
bool heshu[maxn];
void getPrime(int n)
{
    for (int i = 2; i <= n; ++i)
    {
        if (!heshu[i])
            prime[++prime[0]] = i;
        for (int j = 1; j <= prime[0] && i * prime[j] <= n; ++j)
        {
            heshu[i * prime[j]] = true; //找到的素数的倍数不访问
            if (i % prime[j] == 0)
                break;
        }
    }
}
\end{lstlisting}
\subsubsection{有关素数的基础算法}
素数判定
\begin{lstlisting}
bool isPrime(int n)
{
    if (n == 1)
        return false;
    if (n == 2 || n == 3)
        return true;
    if (n % 6 != 1 && n % 6 != 5)
        return false;
    for (int i = 5; i * i <= n; i += 6)
        if (n % i == 0 || n % (i + 2) == 0)
            return false;
    return true;
}
\end{lstlisting}
约数枚举
\begin{lstlisting}
vector<int> res;
void divisor(int n)
{
    for (int i = 1; i * i <= n; ++i)
        if (n % i == 0)
        {
            res.push_back(i);
            if (i != n / i)
                res.push_back(n / i);
        }
}
\end{lstlisting}
\subsubsection{Miller Rabin}
\begin{lstlisting}
typedef long long ll;
ll Mul(ll a, ll b, ll mod)
{
    if (mod <= 1000000000)
        return a * b % mod;
    else if (mod <= 1000000000000LL)
        return (((a * (b >> 20) % mod) << 20) + (a * (b & ((1 << 20) - 1)))) % mod;
    else
    {
        ll d = (ll)floor(a * (long double)b / mod + 0.5);
        ll res = (a * b - d * mod) % mod;
        if (res < 0)
            res += mod;
        return res;
    }
}

bool Miller_Rabin(ll n, int s) //s >= 8
{
    if (n == 2)
        return true;
    if (n < 2 || !(n & 1))
        return false;
    int t = 0;
    ll u = n - 1;
    while ((u & 1) == 0)
        ++t, u >>= 1;
    for (int i = 0; i < s; ++i)
    {
        ll a = rand() % (n - 1) + 1;
        ll x = mod_pow(a, u, n);
        for (int j = 0; j < t; ++j)
        {
            ll y = Mul(x, x, n);
            if (y == 1 && x != 1 && x != n - 1)
                return false;
            x = y;
        }
        if (x != 1)
            return false;
    }
    return true;
}
\end{lstlisting}
\subsubsection{区间素数筛}
\begin{lstlisting}
bool is_prime[1000]; //is_prime[i-a]=true <=> i是素数
bool is_prime_small[100];
ll prime[maxn];               //只求素数个数时可省略
int segment_sieve(ll a, ll b) //对区间[a,b)内的整数执行筛法
{
    for (ll i = 0; i * i < b; ++i) //直接 i*i 会溢出
        is_prime_small[i] = true;
    for (ll i = 0; i < b - a; ++i)
        is_prime[i] = true;
    for (ll i = 2; i * i < b; ++i)
        if (is_prime_small[i])
        {
            for (ll j = 2 * i; j * j < b; j += i) //筛[2,sqrt(b))
                is_prime_small[i] = false;
            for (ll j = max(2LL, (a + i - 1) / i) * i; j < b; j += i) //筛[a,b)
                is_prime[j - a] = false;
        }
    int cnt = 0;
    for (ll i = 0; i < b - a; ++i)
        if (is_prime[i])
            prime[cnt++] = i + a; // ++cnt;
    return cnt;
}
\end{lstlisting}
\begin{lstlisting}
ans = segment_sieve(a, b + 1) - (a == 1)); //[a,b]
\end{lstlisting}
\subsection{Euler}
\subsubsection{欧拉函数}
欧拉函数的值等于不超过m并且和m互素的数的个数
\begin{lstlisting}
ll euler(ll n) //求欧拉函数值
{
    ll res = n;
    for (ll i = 2; i * i <= n; ++i)
        if (n % i == 0)
        {
            res = res / i * (i - 1);
            while (n % i == 0)
                n /= i;
        }
    if (n != 1)
        res = res / n * (n - 1);
    return res;
}
int phi[maxn];
void euler_phi(int n) //筛出欧拉函数值的表
{
    for (int i = 0; i <= n; ++i)
        phi[i] = i;
    for (int i = 2; i <= n; ++i)
        if (phi[i] == i)
            for (int j = i; j <= n; j += i)
                phi[j] = phi[j] / i * (i - 1);
}
\end{lstlisting}
\subsubsection{欧拉降幂}
Euler Theorem
费马小定理 (p为素数)
$a^b = a^{b mod (p-1)} mod p$
扩展欧拉定理（欧拉降幂）(a和p不互质)
$a^b mod p = a^b mod P   (b < phi(p))$
$a^b mod p = a^{b mod phi(p) + phi(p)} mod p     (b >= phi(p))$
指数循环节：从 $a^0$ 到 $a^{phi(p)-1}$ 不是重复的，从 $a^{phi(p)}$ 开始出现循环节，长度为 $phi(p)$
$a^b mod p (1<=a<=1e9，1<=b<=10^2e7，1<=p<=1e6)$
\begin{lstlisting}
ll solve(ll a, string &str, ll p)
{
    int phi = euler_phi(p);
    bool flag = false;
    ll b = 0;
    for (int i = 0; i < str.length(); ++i)
    {
        b = b * 10 + str[i] - '0';
        if (b >= phi)
            b %= phi, flag = true;
    }
    if (flag) //只有b >= phi时才 b += phi
        b += phi;
    return mod_pow(a, b, p);
}
\end{lstlisting}
\subsection{Basic Number Theory}
\subsubsection{扩展欧几里得}
裴蜀定理
设a,b是不全为零的整数，则存在整数x,y，使得 $ax+by = gcd(a,b)$
$ax+by = gcd(a,b) = gcd(b,a \% b) = b{x}'+(a \% b){y}'$
将 $a%b = a-(a/b) * b$ 代入得 $ax+by = a{y}'+b({x}'-(a/b) * {y}')$
即 $x = {y}', y = {x}'-(a/b)*x（x,y的值基于{x}',{y}'）$
递归基：当b=0时有 $a * 1+b * 0=a=gcd(a,b) <=> x=1,y=0$
\begin{lstlisting}
ll exgcd(ll a, ll b, ll &x, ll &y) //返回值为gcd(a,b)（a,b非负）
{                                  //a%d或b%d不等于零无解
    ll d = a;
    if (b == 0)
        x = 1, y = 0;
    else
        d = exgcd(b, a % b, y, x), y -= (a / b) * x;
    return d;
}
\end{lstlisting}
\begin{lstlisting}
// 最大公约数 (Greatest Common Divisor)
// O(logN) 其中 N 和 a,b 同阶
ll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); }
// 最小公倍数 (Least Common Multiple)
ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }
\end{lstlisting}
\subsubsection{ax+by=c}
已知a,b,c，求x，使得 $ax \equiv b \pmod {n}$
\begin{lstlisting}
bool solve(ll a, ll b, ll c, ll &x, ll &y)
{
    ll d = exgcd(a, b, x, y);
    if (c % d != 0) //无解
        return false;
    int k = c / d;
    x *= k, y *= k;
    // x = (x % k + k) % k; //最小正整数解
    return true;
}
\end{lstlisting}
\subsubsection{乘法逆元}
乘法逆元（Multiplicative Inverse Modulo）
求 $a$ 在模 $m$ 下的逆元，需要保证 $gcd(a,m)=1$
\begin{lstlisting}
ll inv(ll a, ll m)
{
    ll x, y;
    ll d = exgcd(a, m, x, y);
    return d == 1 ? (x % m + m) % m : -1;
}
\end{lstlisting}
费马小定理 $a<m$ 且 $m$ 为素数
\begin{lstlisting}
ll inv(ll a, ll m) { return mod_pow(a, m - 2, m); }
\end{lstlisting}
线性求逆元 $O(n)$
求 $1~n$ 中所有整数在模 $p$ 意义下的乘法逆元（$p$ 为质数）
\begin{lstlisting}
ll inv[maxn];
inv[1] = 1;
for (int i = 2; i <= n; ++i)                   //中间会溢出，需要类型转换
    inv[i] = (ll)(p - p / i) * inv[p % i] % p; //加上p去除负号
\end{lstlisting}
线性求任意n个数的逆元 $O(n + \log p)$
\begin{lstlisting}
ll a[maxn], s[maxn], sv[maxn];
void solve(int n)
{ // inv[i] = sv[i] * s[i - 1] % p;
    s[0] = 1;
    for (int i = 1; i <= n; ++i)
    {
        input(a[i]);
        s[i] = s[i - 1] * a[i] % p;
    }
    sv[n] = mod_pow(s[n], p - 2, p);
    for (int i = n; i >= 1; --i)
        sv[i - 1] = sv[i] * a[i] % p;
}
\end{lstlisting}
\subsubsection{离散对数}
$a^x = b mod p$  a,p不一定互质
复杂度：$O(\sqrt{p})$
\begin{lstlisting}
unordered_map<ll, ll> mp;
ll exbsgs(ll a, ll b, ll p)
{
    if (b == 1LL)
        return 0;
    ll t, d = 1, k = 0;
    while ((t = gcd(a, p)) != 1)
    {
        if (b % t)
            return -1;
        ++k, b /= t, p /= t, d = d * (a / t) % p;
        if (b == d)
            return k;
    }
    mp.clear();
    ll m = ceil(sqrt(p));
    ll a_m = mod_pow(a, m, p), mul = b;
    for (ll j = 1; j <= m; ++j)
        mul = mul * a % p, mp[mul] = j;
    for (ll i = 1; i <= m; ++i)
    {
        d = d * a_m % p;
        if (mp[d])
            return i * m - mp[d] + k;
    }
    return -1;
}
\end{lstlisting}
\subsubsection{算术基本定理}
**算术基本定理**
任何一个大于 $1$ 的自然数 $n$，如果 $n$ 不为质数，那么 $n$ 可以唯一分解成有限个质数的乘积
$n = p_1^{a_1} * p_2^{a2}...p_n^{a_n}$（$p_1 < p_2...< p_n$ 均为质数，指数 $a_i$ 是正整数）
复杂度：$O(\sqrt{n})$
\begin{lstlisting}
map<ll, ll> mp;          //素因数及其次数
void primer_factor(ll n) //素因数分解
{
    mp.clear();
    //for (int i = 2; i * i <= n; ++i)
    for (int i = 1; i <= prime[0] && prime[i] * prime[i] <= n; ++i)
        while (n % prime[i] == 0)
            ++mp[prime[i]], n /= prime[i];
    if (n > 1)
        mp[n] = 1;
}
\end{lstlisting}
求 $n$ 的因子个数
\begin{lstlisting}
ll ans = 1;
for (auto &i : mp)
    ans *= (1 + i.second);
\end{lstlisting}

求区间 $[a,b]$ 中与 $m$ 互质的数的个数
\begin{lstlisting}
ll dfs(int now, ll n) //求不与m互质的数的个数
{
    ll res = 0;
    for (int i = now; i <= cnt; ++i)
        res += n / fact[i] - dfs(i + 1, n / fact[i]);
    return res;
}
ll solve(int a, int b, int m)
{
    int cnt = getFactors(m);
    return (b - dfs(1, b)) - (a - 1 - dfs(1, a - 1));
}
\end{lstlisting}
\subsection{Modulo Linear Equation}
\subsubsection{中国剩余定理}
中国剩余定理（Chinese Remainder Theory）
求出方程组 $x \equiv r_i \pmod {m_i}(0 \leq i < n)$ 的解 x \\
其中 $m_i$ 两两互质 \\
引用返回通解 $X = res + k * M$ \\
复杂度：$O(n \log m)$，其中 $m$ 和每个 $m_i$ 同阶
\begin{lstlisting}
void crt(ll r[], ll m[], ll n, ll &res, ll &M)
{
    M = 1, res = 0;
    for (int i = 0; i < n; ++i)
        M *= m[i];
    for (int i = 0; i < n; ++i)
    {
        ll x, y, temp = M / m[i];
        exgcd(temp, m[i], x, y);
        res = (res + temp * x * r[i]) % M;
    }
    res = (res % M + M) % M;
}
\end{lstlisting}
\subsubsection{ExCRT}
\begin{lstlisting}
bool excrt(ll r[], ll m[], ll n, ll &res, ll &M)
{
    ll a, b, c, x, y;
    M = m[0], res = r[0];
    for (int i = 1; i < n; ++i)
    {
        a = M, b = m[i], c = r[i] - res;
        ll d = exgcd(a, b, x, y);
        if (c % d != 0)
            return false;
        x = Mul(x, c / d, b / d); //爆long long，需要快速乘
        res += x * M;
        M = M / d * m[i];
        res %= M;
    }
    res = (res % M + M) % M;
    return true;
}
\end{lstlisting}
\subsection{Combinatorics}
\subsubsection{Lucas}
$C_{n}^{m} = \frac{n!}{(n-m)!m!}（m \leq n）$
$1 \leq n,m \leq 10^9, 1<p<10^5且p是素数$
\begin{lstlisting}
//注意如果下标是n+m，则数组大小应为n+m，设为n会越界
const int maxx = min(maxn, maxp);
ll F[maxx];             //F[n]表示n!%p的值
void init(int up, ll p) //up = min(maxn,maxp)
{
    F[0] = 1;
    for (int i = 1; i <= up; ++i)
        F[i] = F[i - 1] * i % p; // % mod
}
ll inv(ll n, ll p) //阶乘n!的逆元
{
    if (n == 1)
        return 1;
    return inv(p % n, p) * (p - p / n) % p;
}
ll lucas(ll n, ll m, ll p)
{
    ll res = 1;
    while (n && m)
    {
        ll a = n % p, b = m % p;
        if (a < b)
            return 0;
        res = res * F[a] % p * inv(F[b] * F[a - b] % p, p) % p;
        n /= p, m /= p;
    }
    return res;
}
\end{lstlisting}
\subsubsection{exlucas}
$C_{n}^{m} = \frac{n!}{(n-m)!m!}（m \leq n）$
$1 <= n,m <= 1e18, 2<=p<1e6, 不保证p是素数$
\begin{lstlisting}
ll calc(ll n, ll pi, ll pk)
{
    if (n == 0)
        return 1;
    ll res = 1;
    for (ll i = 2; i <= pk; ++i)
        if (i % pi)
            res = res * i % pk;
    res = mod_pow(res, n / pk, pk);
    for (ll i = 2; i <= n % pk; ++i)
        if (i % pi)
            res = res * i % pk;
    return res * calc(n / pi, pi, pk) % pk;
}
ll multilucas(ll n, ll m, ll pi, ll pk) //pi为质数，返回C(n,m)%pk,(pk为pi的多次方)
{
    ll x = calc(n, pi, pk), y = calc(m, pi, pk), z = calc(n - m, pi, pk);
    ll cnt = 0;
    for (ll i = n; i; i /= pi)
        cnt += i / pi;
    for (ll i = m; i; i /= pi)
        cnt -= i / pi;
    for (ll i = n - m; i; i /= pi)
        cnt -= i / pi;
    ll res = x * inv(y, pk) % pk * inv(z, pk) % pk * mod_pow(pi, cnt, pk) % pk;
    return res;
}
ll exlucas(ll n, ll m, ll p) //返回C(n,m)%p,m>n情况下返回-1
{
    if (m > n)
        return -1; //组合式没意义
    ll id = p, res = 0;
    for (ll i = 2; i <= id; ++i)
    {
        if (id % i == 0)
        {
            ll pk = 1;
            while (id % i == 0)
                pk *= i, id /= i;
            res = (res + multilucas(n, m, i, pk) * (p / pk) % p * inv(p / pk, pk) % p) % p; //中国剩余定理合并
        }
    }
    return res;
}
\end{lstlisting}
\subsubsection{Polya}
**Polya计数定理** 先把所有方案重复计算了相同的次数，然后再把结果除以重复的次数

推论：一共$n$个置换，第$i$个置换的循环节个数为$gcd(i,n)$
$N*N$的正方形格子，$c^{n^2}+2c^{\frac{n^2+3}{4}}+c^{\frac{n^2+1}{2}}+2c^{n\frac{n+1}{2}}+2c^{\frac{n(n+1)}{2}}$
正六面体，$\frac{m^8+17m^4+6m^2}{24}$
正四面体，$\frac{m^4+11m^2}{12}$

长度为 $n$ 的项链串用 $c$ 种颜色染
$\frac{1}{n} \displaystyle \sum_{d|n} \varphi(n/d) c^d$
\begin{lstlisting}
ll solve(int n, int c)
{
    ll ans = 0;
    primer_factor(n); //素因数分解
    divisor(n);       //约数枚举
    for (auto i : res)
    { //求i的欧拉函数值
        ll euler = i;
        for (auto j : mp)
            if (i % j.first == 0)
                euler = euler / j.first * (j.first - 1);
        ans = (ans + euler * mod_pow(c, n / i, mod) % mod) % mod;
    }
    //最后除以n
    ans = ans * mod_pow(n, mod - 2, mod) % mod;
    return ans;
}
\end{lstlisting}
每种颜色至少涂多少个，求方案数
\begin{lstlisting}
ll polya(int a) //a为循环节长度
{
    ll dp[65][65] = {0}; //前者为颜色，后者为未填充格子个数
    int tot = 60 / a, limit = 0;
    dp[0][tot] = 1;
    for (int i = 1; i <= n; i++)
    {
        int tmp = (c[i] + a - 1) / a;
        int up2 = tot - limit;
        int up1 = up2 - tmp;           //最多空tot-(limit + tmp)
        for (int j = 0; j <= up1; j++) //最少空0个，即填满
        {
            for (int k = tmp; j + k <= up2; k++) //至少选tmp个，最多选tot - limit -j
                (dp[i][j] += dp[i - 1][j + k] * C[j + k][k]) %= p;
        }
        limit += tmp;
    }
    return dp[n][0];
}
\end{lstlisting}
每种颜色要有多少个，求恰好满足的方案数
\begin{lstlisting}
bool check(int b) //a[i]是每种颜色有多少个，b是循环节长度
{
    for (int i = 0; i < n; i++)
        if (a[i] % b)
            return false;
    return true;
}
ll solve(int tot, int b) //tot是总数，b是循环节长度
{
    if (!check(b))
        return 0;
    ll res = 1, cnt = tot / b; //cnt循环节个数
    for (int i = 0; i < 6; i++)
    {
        res *= C[cnt][a[i] / b];
        cnt -= a[i] / b;
    }
    return res;
}
\end{lstlisting}

## poj 2409
既能旋转，也能翻转
\begin{lstlisting}
ll solve(int c, int n)
{
    if (n == 0)
        return 0;
    ll res = 0;
    for (int i = 1; i <= n; i++)
        res += mod_pow(c, gcd(i, n));
    if (n & 1)
        res += n * mod_pow(c, (n + 1) >> 1);
    else
        res += n / 2 * (1 + c) * mod_pow(c, n >> 1);
    return res / n / 2;
}
\end{lstlisting}
\subsubsection{杨辉三角}
杨辉（帕斯卡）三角 $C_n^m = C_{n-1}^{m-1} + C_{n-1}^m$
$n \leq 1000$
\begin{lstlisting}
void init(int n)
{
    C[0][0] = 1;
    for (int i = 1; i <= n; ++i)
    {
        C[i][0] = 1;
        for (int j = 1; j <= i; ++j)
            C[i][j] = (C[i-1][j-1] + C[i-1][j]) % mod;
    }
}
\end{lstlisting}


$C[i]$ = $C_{n}^{i}$
\begin{lstlisting}
void init(int n)
{
    C[0] = 1;
    for (int i = 1; i <= n; ++i)
        C[i] = C[i - 1] * (n - i + 1) / i;
}
\end{lstlisting}
\subsection{Fast Power}
\subsubsection{快速幂}
给定 $a,b,m$，求 $a^b mod m$
复杂度：$O(\sqrt{b})$
\begin{lstlisting}
ll mod_pow(ll a, ll b, ll m)
{
    a %= m;
    ll res = 1;
    while (b)
    {
        if (b & 1)
            res = res * a % m;
        a = a * a % m, b >>= 1;
    }
    return res %= m; //注意：1%1不等于1而等于0
}
\end{lstlisting}

注意：根据费马小定理，如果 $m$ 是一个质数，
我们可以计算 $a^{b mod (m-2)}$ 来加速算法过程


定长路径计数
给一个有向图（边权为1），求任意两点u,v间从u到v，长度为k的路径的条数
把该图的邻接矩阵M取k次幂，那么M(i,j)就表示从i到j长度为k的路径的数目
复杂度：$O(n^3 \sqrt{k})$\subsubsection{快速乘}
\begin{lstlisting}
inline ll Mul(ll a, ll b, ll m)
{
    if (m <= 1000000000)
        return a * b % m;
    else if (m <= 1000000000000LL)
        return (((a * (b >> 20) % m) << 20) + (a * (b & ((1 << 20) - 1)))) % m;
    else
    {
        ll d = (ll)floor(a * (long double)b / m + 0.5);
        ll res = (a * b - d * m) % m;
        if (res < 0)
            res += m;
        return res;
    }
}
\end{lstlisting}
\subsection{Mobius Inversion}
\subsubsection{莫比乌斯反演}
Mobius Inversion
$F(n)=\sum_{d|n}f(d)\Rightarrow f(n)=\sum_{d|n}\mu(d)F(\frac{n}{d})$
$F(n)=\sum_{n|d}f(d)\Rightarrow f(n)=\sum_{n|d}\mu(\frac{d}{n})F(d)$
\begin{lstlisting}
int prime[maxn], mu[maxn];
bool heshu[maxn];
void getMu(int n)
{
    mu[1] = 1;
    for (int i = 2; i <= n; ++i)
    {
        if (!heshu[i])
            prime[++prime[0]] = i, mu[i] = -1;
        for (int j = 1; j <= prime[0] && i * prime[j] <= n; ++j)
        {
            heshu[i * prime[j]] = true;
            if (i % prime[j] == 0)
            {
                mu[i * prime[j]] = 0;
                break;
            }
            else
                mu[i * prime[j]] = -mu[i];
        }
    }
}
\end{lstlisting}
\subsubsection{例子}
有$n$个数$(n \leq 100000,1 \le  a_i \le 10 ^ 6)$，问这$n$个数中互质的数的对数
\begin{lstlisting}
int b[maxn];
ll solve(int n)
{
    ll ans = 0;
    for (int i = 0, x; i < n; i++) scanf("%d", &x), b[x]++;
    for (int i = 1; i < maxn; i++)
    {
        int cnt = 0;
        for (int j = i; j < maxn; j += i) cnt += b[j];
        ans += 1LL * mu[i] * cnt * cnt;
    }
    return (ans - b[1]) / 2;
}
\end{lstlisting}
$\gcd(x,y)=1$的对数, $x \leq n, y \leq m$
\begin{lstlisting}
ll solve(int n, int m)
{
    if (n > m) swap(n, m);
    ll ans = 0;
    for (int i = 1; i <= n; i++) ans += (ll)mu[i] * (n / i) * (m / i);
    /* 
    数论分块写法(sum为莫比乌斯函数的前缀和)
    for (int i = 1; i <= n; i = pos + 1)
    {
        pos = min(n / (n / i), m / (m / i));
        ans += 1LL * (sum[pos] - sum[i - 1]) * (n / i) * (m / i);
    }
    */
    return ans;
}
\end{lstlisting}
\subsection{Fast Transformation}
\subsubsection{FFT}
\begin{lstlisting}
const double PI = acos(-1.0);
//复数结构体
struct Complex
{
    double x, y; //实部和虚部 x+yi
    Complex(double _x = 0.0, double _y = 0.0) { x = _x, y = _y; }
    Complex operator-(const Complex& b) const { return Complex(x - b.x, y - b.y); }
    Complex operator+(const Complex& b) const { return Complex(x + b.x, y + b.y); }
    Complex operator*(const Complex& b) const { return Complex(x * b.x - y * b.y, x * b.y + y * b.x); }
};
void change(Complex y[], int len)
{
    for (int i = 1, j = len / 2; i < len - 1; i++)
    {
        if (i < j) swap(y[i], y[j]);
        int k = len / 2;
        while (j >= k) j -= k, k /= 2;
        if (j < k) j += k;
    }
}
/*
* len必须为2^k形式，
* on==1时是DFT，on==-1时是IDFT
*/
void fft(Complex y[], int len, int on)
{
    change(y, len);
    for (int h = 2; h <= len; h <<= 1)
    {
        Complex wn(cos(-on * 2 * PI / h), sin(-on * 2 * PI / h));
        for (int j = 0; j < len; j += h)
        {
            Complex w(1, 0);
            for (int k = j; k < j + h / 2; k++)
            {
                Complex u = y[k];
                Complex t = w * y[k + h / 2];
                y[k] = u + t, y[k + h / 2] = u - t;
                w = w * wn;
            }
        }
    }
    if (on == -1)
        for (int i = 0; i < len; i++) y[i].x /= len;
}
\end{lstlisting}
\subsubsection{NTT}
模数P为费马素数，G为P的原根。
$G^{\frac{P-1}{n}}$具有和$w_n=e^{\frac{2i\pi}{n}}$相似的性质。
具体的P和G可参考1.11
\begin{lstlisting}
const int mod = 119 << 23 | 1;
const int G = 3;
int wn[20];
void getwn()
{ //  千万不要忘记
    for (int i = 0; i < 20; i++) wn[i] = Pow(G, (mod - 1) / (1 << i), mod);
}
void change(int y[], int len)
{
    for (int i = 1, j = len / 2; i < len - 1; i++)
    {
        if (i < j) swap(y[i], y[j]);
        int k = len / 2;
        while (j >= k) j -= k, k /= 2;
        if (j < k) j += k;
    }
}
void ntt(int y[], int len, int on)
{
    change(y, len);
    for (int h = 2, id = 1; h <= len; h <<= 1, id++)
    {
        for (int j = 0; j < len; j += h)
        {
            int w = 1;
            for (int k = j; k < j + h / 2; k++)
            {
                int u = y[k] % mod;
                int t = 1LL * w * (y[k + h / 2] % mod) % mod;
                y[k] = (u + t) % mod, y[k + h / 2] = ((u - t) % mod + mod) % mod;
                w = 1LL * w * wn[id] % mod;
            }
        }
    }
    if (on == -1)
    {
        //  原本的除法要用逆元
        int inv = Pow(len, mod - 2, mod);
        for (int i = 1; i < len / 2; i++) swap(y[i], y[len - i]);
        for (int i = 0; i < len; i++) y[i] = 1LL * y[i] * inv % mod;
    }
}
\end{lstlisting}
\subsubsection{FWT}
\begin{lstlisting}
void fwt(int f[], int m)
{
    int n = __builtin_ctz(m);
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < m; ++j)
            if (j & (1 << i))
            {
                int l = f[j ^ (1 << i)], r = f[j];
                f[j ^ (1 << i)] = l + r, f[j] = l - r;
                // or: f[j] += f[j ^ (1 << i)];
                // and: f[j ^ (1 << i)] += f[j];
            }
}
void ifwt(int f[], int m)
{
    int n = __builtin_ctz(m);
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < m; ++j)
            if (j & (1 << i))
            {
                int l = f[j ^ (1 << i)], r = f[j];
                f[j ^ (1 << i)] = (l + r) / 2, f[j] = (l - r) / 2;
                // 如果有取模需要使用逆元
                // or: f[j] -= f[j ^ (1 << i)];
                // and: f[j ^ (1 << i)] -= f[j];
            }
}
\end{lstlisting}
\subsection{数值计算}
\subsubsection{数值积分}
Adaptive Simpson's Rule
给定函数 $f(x)$ ，用数值方法求积分 $\int_{b}^{a} f(x) dx$
\begin{lstlisting}
inline double F(double x) {}
double simpson(double a, double b)
{ // 三点Simpson法
    double c = a + (b - a) / 2;
    return (F(a) + 4 * F(c) + F(b)) * (b - a) / 6;
}
double asr(double a, double b, double eps, double A)
{ //自适应Simpson公式（递归过程）。已知整个区间[a,b]上的三点Simpson值A
    double c = a + (b - a) / 2;
    double L = simpson(a, c), R = simpson(c, b);
    if (fabs(L + R - A) <= 15 * eps)
        return L + R + (L + R - A) / 15.0;
    return asr(a, c, eps / 2, L) + asr(c, b, eps / 2, R);
}
double asr(double a, double b, double eps)
{
    return asr(a, b, eps, simpson(a, b));
}
\end{lstlisting}
\subsubsection{Berlekamp-Massey}
\begin{lstlisting}
ll res[maxn], base[maxn], _c[maxn], _md[maxn];
vector<int> Md;
void mul(ll* a, ll* b, int k)
{
    for (int i = 0; i < k + k; i++) _c[i] = 0;
    for (int i = 0; i < k; i++)
        if (a[i])
            for (int j = 0; j < k; j++) _c[i + j] = (_c[i + j] + a[i] * b[j]) % mod;
    for (int i = k + k - 1; i >= k; i--)
        if (_c[i])
            for (int j = 0; j < Md.size(); j++) _c[i - k + Md[j]] = (_c[i - k + Md[j]] - _c[i] * _md[Md[j]]) % mod;
    for (int i = 0; i < k; i++) a[i] = _c[i];
}
int solve(ll n, VI a, VI b)
{
    ll ans = 0, pnt = 0;
    int k = a.size();
    assert(a.size() == b.size());
    for (int i = 0; i < k; i++) _md[k - 1 - i] = -a[i];
    _md[k] = 1;
    Md.clear();
    for (int i = 0; i < k; i++)
        if (_md[i] != 0) Md.push_back(i);
    for (int i = 0; i < k; i++) res[i] = base[i] = 0;
    res[0] = 1;
    while ((1LL << pnt) <= n) pnt++;
    for (int p = pnt; p >= 0; p--)
    {
        mul(res, res, k);
        if ((n >> p) & 1)
        {
            for (int i = k - 1; i >= 0; i--) res[i + 1] = res[i];
            res[0] = 0;
            for (int j = 0; j < Md.size(); j++) res[Md[j]] = (res[Md[j]] - res[k] * _md[Md[j]]) % mod;
        }
    }
    for (int i = 0; i < k; i++) ans = (ans + res[i] * b[i]) % mod;
    if (ans < 0) ans += mod;
    return ans;
}
VI BM(VI s)
{
    VI C(1, 1), B(1, 1);
    int L = 0, m = 1, b = 1;
    for (int n = 0; n < s.size(); n++)
    {
        ll d = 0;
        for (int i = 0; i <= L; i++) d = (d + (ll)C[i] * s[n - i]) % mod;
        if (d == 0)
            ++m;
        else if (2 * L <= n)
        {
            VI T = C;
            ll c = mod - d * Pow(b, mod - 2) % mod;
            while (C.size() < B.size() + m) C.push_back(0);
            for (int i = 0; i < B.size(); i++) C[i + m] = (C[i + m] + c * B[i]) % mod;
            L = n + 1 - L, B = T, b = d, m = 1;
        }
        else
        {
            ll c = mod - d * Pow(b, mod - 2) % mod;
            while (C.size() < B.size() + m) C.push_back(0);
            for (int i = 0; i < B.size(); i++) C[i + m] = (C[i + m] + c * B[i]) % mod;
            ++m;
        }
    }
    return C;
}
int gao(VI a, ll n)
{
    VI c = BM(a);
    c.erase(c.begin());
    for (int i = 0; i < c.size(); i++) c[i] = (mod - c[i]) % mod;
    return solve(n, c, VI(a.begin(), a.begin() + c.size()));
}
\end{lstlisting}
\subsubsection{Simplex}
输入矩阵$a$描述线性规划的标准形式。\\\\
$a$为$m+1$行$n+1$列，其中行$0 \sim m-1$为不等式，行$m$为目标函数（最大化）。\\\\
列$0 \sim n-1$为变量$0 \sim n-1$的系数，列$n$为常数项。\\\\
约束为$a_{i, 0}x_0 + a_{i, 1}x_1 + \cdots \le a_{i, n}$，目标为$\max(a_{m, 0}x_0 + a_{m, 1}x_1 + \cdots + a_{m, n - 1}x_{n - 1} - a_{m, n})$\\\\
注意：变量均有非负约束$x[i] \ge 0$
\begin{lstlisting}
const int maxm = 500; // 约束数目上限
const int maxn = 500; // 变量数目上限
const double INF = 1e100;
const double eps = 1e-10;
struct Simplex
{
    int n;                // 变量个数
    int m;                // 约束个数
    double a[maxm][maxn]; // 输入矩阵
    int B[maxm], N[maxn]; // 算法辅助变量
    void pivot(int r, int c)
    {
        swap(N[c], B[r]);
        a[r][c] = 1 / a[r][c];
        for (int j = 0; j <= n; j++)
            if (j != c) a[r][j] *= a[r][c];
        for (int i = 0; i <= m; i++)
            if (i != r)
            {
                for (int j = 0; j <= n; j++)
                    if (j != c) a[i][j] -= a[i][c] * a[r][j];
                a[i][c] = -a[i][c] * a[r][c];
            }
    }
    bool feasible()
    {
        for (;;)
        {
            int r, c;
            double p = INF;
            for (int i = 0; i < m; i++)
                if (a[i][n] < p) p = a[r = i][n];
            if (p > -eps) return true;
            p = 0;
            for (int i = 0; i < n; i++)
                if (a[r][i] < p) p = a[r][c = i];
            if (p > -eps) return false;
            p = a[r][n] / a[r][c];
            for (int i = r + 1; i < m; i++)
                if (a[i][c] > eps)
                {
                    double v = a[i][n] / a[i][c];
                    if (v < p) r = i, p = v;
                }
            pivot(r, c);
        }
    }
    // 解有界返回1，无解返回0，无界返回-1。b[i]为x[i]的值，ret为目标函数的值
    int simplex(int n, int m, double x[maxn], double& ret)
    {
        this->n = n, this->m = m;
        for (int i = 0; i < n; i++) N[i] = i;
        for (int i = 0; i < m; i++) B[i] = n + i;
        if (!feasible()) return 0;
        for (;;)
        {
            int r, c;
            double p = 0;
            for (int i = 0; i < n; i++)
                if (a[m][i] > p) p = a[m][c = i];
            if (p < eps)
            {
                for (int i = 0; i < n; i++)
                    if (N[i] < n) x[N[i]] = 0;
                for (int i = 0; i < m; i++)
                    if (B[i] < n) x[B[i]] = a[i][n];
                ret = -a[m][n];
                return 1;
            }
            p = INF;
            for (int i = 0; i < m; i++)
                if (a[i][c] > eps)
                {
                    double v = a[i][n] / a[i][c];
                    if (v < p) r = i, p = v;
                }
            if (p == INF) return -1;
            pivot(r, c);
        }
    }
};
\end{lstlisting}
\subsection{Matrix}
\subsubsection{矩阵快速幂}
\begin{lstlisting}
typedef vector<ll> vec;  //要用long long，不然会爆
typedef vector<vec> mat; //n*m的矩阵：mat A(n, vec(m))
mat mul(mat &A, mat &B)  //计算A*B
{
    mat C(A.size(), vec(B[0].size())); //A矩阵的行数、B矩阵的列数
    for (int i = 0; i < A.size(); ++i)
        for (int k = 0; k < B.size(); ++k)
            if (A[i][k]) //对稀疏矩阵的优化
                for (int j = 0; j < B[0].size(); ++j)
                    C[i][j] = (C[i][j] + A[i][k] * B[k][j] % mod) % mod; //中间也要取模，不然会爆
    return C;
}
mat matpow(mat A, ll k) //计算A^k
{
    mat B(A.size(), vec(A.size()));
    for (int i = 0; i < A.size(); ++i) //单位矩阵
        B[i][i] = 1;
    for (; k; k >>= 1, A = mul(A, A))
        if (k & 1)
            B = mul(B, A);
    return B;
}
\end{lstlisting}
\subsubsection{高斯消元}
$O(n^3)$
\begin{lstlisting}
double a[maxn][maxn];
bool gauss(int equ, int var) //方程数和未知量个数，无解返回false
{
    for (int now = 1, col = 1; now <= equ && col <= var; ++now, ++col) //当前行和当前列
    {
        int max_r = now;
        for (int i = now + 1; i <= equ; ++i)
            if (fabs(a[max_r][col]) < fabs(a[i][col]))
                max_r = i;             //用最大项系数来消掉其他系数
        if (fabs(a[max_r][col]) < eps) //无解
            return false;
        if (now != max_r) //交换行
            for (int j = 1; j <= var + 1; ++j)
                swap(a[now][j], a[max_r][j]);
        double temp = a[now][col]; //a[now][col]的值会变化，必须用辅助变量
        for (int j = col; j <= var + 1; ++j)
            a[now][j] /= temp;
        for (int i = 1; i <= equ; ++i)
            if (i != now)
            {
                temp = a[i][col];
                for (int j = col + 1; j <= var + 1; ++j)
                    a[i][j] -= temp * a[now][j];
            }
    }
    return true;
}
\end{lstlisting}
\subsection{OverFlow}
\subsubsection{判断溢出}
\begin{lstlisting}
#include <climits>
// INT_MAX、INT_MIN、UINT_MAX
// LLONG_MAX、LLONG_MIN、ULLONG_MAX
bool is_add_overflow(unsigned int a, unsigned int b) //无符号整数相加
{
    return a > UINT_MAX - b;
}
bool is_add_overflow2(int a, int b) //有符号整数相加（一正一负相加不可能溢出）
{
    if (a > 0 && b > 0 && a > INT_MAX - b)
        return true;
    if (a < 0 && b < 0 && a < INT_MIN - b)
        return true;
    return false;
}
bool is_mul_overflow(int a, int b) //两数相乘
{
    if (a >= 0 && b >= 0)
        return a > INT_MAX / b;
    else if (a < 0 && b < 0)
        return a < INT_MAX / b;
    else
        return a < 0 ? is_mul_overflow(-a, b) : is_mul_overflow(a, -b);
}
\end{lstlisting}
\subsubsection{格雷码}
给定一个二进制位的位数 ，求出一个 $0$ 到 $2^n - 1$ 的排列，使得相邻两项 \\
（包括头尾相邻）的二进制表达中只有恰好一位不同 \\
$Grey$ 序列的第 $i$ 位为 $i xor (i \gg 1)$ \\
复杂度：$O(2^n)$
\begin{lstlisting}
vector<int> Gray;
void Gray_Create(int n)
{
    for (int i = 0; i < (1 << n); ++i)
        Gray.push_back(i ^ (i >> 1));
}
\end{lstlisting}
\subsection{BigInt}
\subsubsection{Bint}
加法 乘法 小于号 输出
\begin{lstlisting}
struct bint
{
    int l;
    short int w[505]; //505位
    bint(string x = "")
    {
        memset(w, 0, sizeof(w));
        l = x.length();
        for (int i = 0; i < l; ++i)
            w[i] = x[l - 1 - i] - '0';
    }
    bool operator<(const bint &x) const
    {
        if (l != x.l)
            return l < x.l;
        int i = l - 1;
        while (i >= 0 && w[i] == x.w[i])
            i--;
        return (i >= 0 && w[i] < x.w[i]);
    }
    bint operator+(const bint &x) const
    {
        bint ans;
        ans.l = l > x.l ? l : x.l;
        for (int i = 0; i < ans.l; ++i)
        {
            ans.w[i] += w[i] + x.w[i];
            ans.w[i + 1] += ans.w[i] / 10;
            ans.w[i] = ans.w[i] % 10;
        }
        if (ans.w[ans.l] != 0)
            ans.l++;
        return ans;
    }
    bint operator*(const bint &x) const
    {
        bint res;
        int up, tmp;
        for (int i = 0; i < l; ++i)
        {
            up = 0;
            for (int j = 0; j < x.l; ++j)
            {
                tmp = w[i] * x.w[j] + res.w[i + j] + up;
                res.w[i + j] = tmp % 10;
                up = tmp / 10;
            }
            if (up != 0)
                res.w[i + x.l] = up;
        }
        res.l = l + x.l;
        while (res.w[res.l - 1] == 0 && res.l > 1)
            res.l--;
        return res;
    }
    void print()
    {
        for (int i = l - 1; ~i; --i)
            printf("%d", w[i]);
        puts("");
    }
};

string x, y;
cin >> x >> y;
bint a{x}, b{y};
bint ans = a * b;
ans.print();
\end{lstlisting}
\subsection{Formula}
\begin{enumerate}
    \item 约数定理：若$n=\prod_{i=1}^kp_i^{a_i}$，则
    
    \begin{enumerate}
    \item 约数个数$f(n)=\prod_{i=1}^k(a_i+1)$
    \item 约数和$g(n)=\prod_{i=1}^k(\sum_{j=0}^{a_i}p_i^j)$
    \end{enumerate}
    
    \item 小于$n$且互素的数之和为$n\varphi(n)/2$
    
    \item 若$\gcd(n,i)=1$，则$\gcd(n,n-i)=1(1\leq i\leq n)$
    
    \item 错排公式：$D(n)=(n-1)(D(n-2)+D(n-1))=\sum_{i=2}^n\frac{(-1)^kn!}{k!}=[\frac{n!}{e}+0.5]$
    
    \item 威尔逊定理：$p\ is\ prime\ \Rightarrow (p-1)!\equiv-1\pmod p$
    
    \item 欧拉定理：$\gcd(a,n)=1\Rightarrow a^{\varphi(n)}\equiv1\pmod n$
    
    \item 欧拉定理推广：$\gcd(n,p)=1\Rightarrow a^n\equiv a^{n\%\varphi(p)}\pmod p$
    
    \item 模的幂公式：$a ^ n \pmod {m} = 
    \begin{cases}
    a ^ n \mod m & n < \varphi(m)\\
    a ^ {n \% \varphi(m) + \varphi(m)} \mod m & n \ge \varphi(m)
    \end{cases}
    $
    
    \item 素数定理：对于不大于$n$的素数个数$\pi(n)$，$\lim\limits_{n\to\infty}\pi(n)=\frac{n}{\ln n}$
    
    \item 位数公式：正整数$x$的位数$N=\log_{10}(n)+1$
    
    \item 斯特灵公式$n!\approx\sqrt{2\pi n}(\frac{n}{e})^n$
    
    \item 设$a>1,m,n>0$,则$\gcd(a^m-1,a^n-1)=a^{\gcd(m,n)}-1$
    
    \item 设$a>b,\gcd(a,b)=1$,则$\gcd(a^m-b^m,a^n-b^n)=a^{\gcd(m,n)}-b^{\gcd(m,n)}$
    
    $$
    G=\gcd(C_n^1,C_n^2,...,C_n^{n-1})=
    \begin{cases}
        n, & \text{$n$ is prime} \\
        1, & \text{$n$ has multy prime factors} \\
        p, & \text{$n$ has single prime factor $p$}
    \end{cases}
    $$
    
    $\gcd(Fib(m),Fib(n))=Fib(\gcd(m,n))$
    
    \item 若$\gcd(m,n)=1$,则:
    
    \begin{enumerate}
    \item 最大不能组合的数为$m*n-m-n$
    \item 不能组合数个数$N=\frac{(m-1)(n-1)}{2}$
    \end{enumerate}
    
    \item $(n+1)lcm(C_n^0,C_n^1,...,C_n^{n-1},C_n^{n})=lcm(1,2,...,n+1)$
    
    \item 若$p$为素数，则$(x+y+...+w)^p\equiv x^p+y^p+...+w^p\pmod p$
    
    \item 卡特兰数：1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012
    
    $h(0)=h(1)=1,h(n)=\frac{(4n-2)h(n-1)}{n+1}=\frac{C_{2n}^n}{n+1}=C_{2n}^n-C_{2n}^{n-1}$
    
    \item 伯努利数：$B_n = -\frac{1}{n+1} \sum_{i=0}^{n-1} C_{n+1}^i B_i$
    
    $$\sum_{i=1}^n i^k = \frac{1}{k+1} \sum_{i=1}^{k+1}C_{k+1}^i B_{k+1-i}(n+1)^i$$
    
    \item 二项式反演：$$f_n = \sum_{i = 0} ^ n (-1) ^ i \binom{n}{i} g_i \Leftrightarrow g_n = \sum_{i = 0} ^ n (-1) ^ i \binom{n}{i} f_i$$
    $$f_n = \sum_{i = 0} ^ n \binom{n}{i} g_i \Leftrightarrow g_n = \sum_{i = 0} ^ n (-1) ^ {n - i} \binom{n}{i} f_i$$
    
    
    \item FFT常用素数
    
    \begin{tabular}{cccc}
        \hline
        $r⋅2^k+1$&$r$&$k$&$g$\\
        \hline
        3&1&1&2\\
        5&1&2&2\\
        17&1&4&3\\
        97&3&5&5\\
        193&3&6&5\\
        257&1&8&3\\
        7681&15&9&17\\
        12289&3&12&11\\
        40961&5&13&3\\
        65537&1&16&3\\
        786433&3&18&10\\
        5767169&11&19&3\\
        7340033&7&20&3\\
        23068673&11&21&3\\
        104857601&25&22&3\\
        167772161&5&25&3\\
        469762049&7&26&3\\
        998244353&119&23&3\\
        1004535809&479&21&3\\
        2013265921&15&27&31\\
        2281701377&17&27&3\\
        3221225473&3&30&5\\
        75161927681&35&31&3\\
        77309411329&9&33&7\\
        206158430209&3&36&22\\
        2061584302081&15&37&7\\
        2748779069441&5&39&3\\
        6597069766657&3&41&5\\
        39582418599937&9&42&5\\
        79164837199873&9&43&5\\
        263882790666241&15&44&7\\
        1231453023109121&35&45&3\\
        1337006139375617&19&46&3\\
        3799912185593857&27&47&5\\
        4222124650659841&15&48&19\\
        7881299347898369&7&50&6\\
        31525197391593473&7&52&3\\
        180143985094819841&5&55&6\\
        1945555039024054273&27&56&5\\
        4179340454199820289&29&57&3\\
        \hline
    \end{tabular}
\end{enumerate}\clearpage\section{String Processing}
\subsection{KMP}
复杂度： $O(n + m)$
返回y中x的个数
\begin{lstlisting}
int kmp[maxn];                //kmp[i]用于记录当匹配到模式串的第i位之后失配，该跳转到模式串的哪个位置，即next(失配)数组
void initkmp(char x[], int m) //预处理模式串的kmp数组  O(n)
{
    int i = 0, pos = kmp[0] = -1; //前一位、前两位失配了，都只可能将第一位作为新的开头
    while (i < m)                 //自己匹配自己
    {
        while (pos != -1 && x[i] != x[pos]) //如果pos=-1，则回跳至第一个字符，不用再回跳了
            pos = kmp[pos];
        kmp[++i] = ++pos; //i+1位失配后应跳至pos位置
    }
}
int KMP(char x[], int m, char y[], int n) // O(n+m)
{
    initkmp(x, m);
    int i = 0, pos = 0, cnt = 0; //pos表示当前已经匹配完的模式串的最后一位的位置
    while (i < n)                //用模式串和文本串对比
    {
        while (pos != -1 && y[i] != x[pos]) //如果失配，那么就不断地回跳，直到可以继续匹配
            pos = kmp[pos];
        ++i, ++pos;
        if (pos >= m)              //一个模式串匹配成功
            ++cnt, pos = kmp[pos]; //匹配下一个
    }
    return cnt;
}
\end{lstlisting}
\subsection{ExtendKMP}
$next[i]:x[i...m-1]与x[0...m-1]$的最长公共前缀
$extend[i]:y[i...n-1]与x[0...m-1]$的最长公共前缀
\begin{lstlisting}
int nxt[maxn], extend[maxn];
//extend[i]为从位置i开始的匹配段长度（其终止位置位于i+extend[i]-1）
void init_exkmp(char x[], int m) // O(n)
{
    nxt[0] = m;
    int j = 0;
    while (j + 1 < m && x[j] == x[j + 1]) //计算next[1]
        ++j;
    nxt[1] = j;
    int k = 1;
    for (int i = 2; i < m; i++)
    {
        int p = nxt[k] + k - 1;
        int L = nxt[i - k];
        if (i + L < p + 1)
            nxt[i] = L;
        else
        {
            j = max(0, p - i + 1);
            while (i + j < m && x[i + j] == x[j])
                ++j;
            nxt[i] = j, k = i;
        }
    }
}
void exkmp(char x[], int m, char y[], int n) // O(n+m)
{
    init_exkmp(x, m);
    int j = 0;
    while (j < n && j < m && x[j] == y[j]) //计算extend[0]
        ++j;
    extend[0] = j;
    int k = 0;
    for (int i = 1; i < n; i++)
    {
        int p = extend[k] + k - 1;
        int L = nxt[i - k];
        if (i + L < p + 1)
            extend[i] = L;
        else
        {
            j = max(0, p - i + 1);
            while (i + j < n && j < m && y[i + j] == x[j])
                ++j;
            extend[i] = j, k = i;
        }
    }
}
\end{lstlisting}
\subsection{Manacher}
时间复杂度 $O(n)$
\begin{lstlisting}
char s[maxn], Ma[maxn << 1];
int Len[maxn << 1]; //Len[i]表示以字符Ma[i]为中心的最长回文字串的最右字符到Ma[i]的长度
int Manacher(char s[], int len)
{
    int pos = 0;
    Ma[pos++] = '$';              //防止越界
    Ma[pos++] = '#';              //在原字符串的每个相邻两个字符中间插入一个分隔符，同时在首尾也要添加一个分隔符
    for (int i = 0; i < len; ++i) //以便将长度为奇数的回文串和长度为偶数的回文串一起考虑
        Ma[pos++] = s[i], Ma[pos++] = '#';
    Ma[pos] = 0;
    int mx = 0, mid = 0; //mx为之前计算中最长回文子串的右端点的最大值，mid为对应字串的对称轴
    for (int i = 0; i < pos; ++i)
    { //mid*2-i=mid-(i-mid)//如果i>=mx，大于mx的部分我们还没有进行匹配，所以要从mx+1位置开始重新开始匹配
        Len[i] = (i < mx) ? min(Len[mid * 2 - i], mx - i) : 1;
        while (Ma[i + Len[i]] == Ma[i - Len[i]])
            ++Len[i];
        if (Len[i] + i > mx)          //若新计算的回文串右端点位置大于mx
            mx = Len[i] + i, mid = i; //更新mx和mid的值
    }
    int ans = 0;
    for (int i = 0; i < 2 * len + 2; ++i)
        if (Len[i] - 1 > ans)
            ans = Len[i] - 1, pos = i;
    //int l = (pos - ans + 1) / 2 - 1, r = (pos + ans - 1) / 2 - 1;
    //for (int i = l; i <= r; ++i)
    //    printf("%c", s[i]);
    return ans;
}
\end{lstlisting}
\subsection{AC自动机}
AC 自动机（Aho-Corasick Automaton）的时间复杂度在需要找到所有匹配位置时是 $O(|s|+m)$，其中|s|表示文本串的长度，m表示模板串的总匹配次数；而只需要求是否匹配时时间复杂度为 $O(|s|)$
\begin{lstlisting}
const int maxn = n * maxLen; //一般 >=1e5
struct Trie
{
    int ch[maxn][26 或 10], f[maxn], val[maxn]; //val[u]为节点u存储的信息
    int sz, rt;                                 //已有节点数、树根
    int newnode()                               //新建节点
    {
        memset(ch[sz], -1, sizeof(ch[sz])), val[sz] = 0;
        return sz++;
    }
    void init() { sz = 0, rt = newnode(); } //初始化，建立根节点
    int idx(char c) { return c - 'a' 或 '0'; };
    void insert(const char *s, int id) //插入模式串(const string &s)
    {
        int u = 0;
        for (int i = 0; s[i]; ++i) //i<s.length()
        {
            int c = idx(s[i]);
            if (ch[u][c] == -1) //如果走不通，新建节点
                ch[u][c] = newnode();
            u = ch[u][c]; //往下走
            /* 中途的操作 */
            //统计以某个字符串为前缀的模式串数量  ++val[u];
        }         //走到底后的操作
        ++val[u]; //字符串结尾，存储模式串个数（存储编号：val[u]=id）
    }

    // 字典树
    int query(const char *s)
    {
        int u = 0;
        for (int i = 0; s[i]; ++i)
        {
            int c = idx(s[i]);
            if (ch[u][c] == -1)
                return -1;
            u = ch[u][c];
        }
        return val[u];
    }

    // AC自动机
    mat base;
    void build()
    {
        queue<int> q;
        f[rt] = rt;
        for (int c = 0; c < 26; ++c)
        {
            if (~ch[rt][c])
                f[ch[rt][c]] = rt, q.push(ch[rt][c]);
            else
                ch[rt][c] = rt;
        }
        while (!q.empty())
        {
            int u = q.front();
            q.pop();
            // val[u] |= val[f[u]];  +=
            for (int c = 0; c < 26; ++c)
                if (~ch[u][c])
                    f[ch[u][c]] = ch[f[u]][c], q.push(ch[u][c]);
                else
                    ch[u][c] = ch[f[u]][c];
        }
        mat A(sz, vec(sz));
        for (int i = 0; i < sz; ++i)
            if (!val[i]) //模式串的终止的都是非法的，不可经过
                for (int j = 0; j < 3; ++j)
                    if (!val[ch[i][j]])
                        ++A[i][ch[i][j]];
        base = A;
    }
    ll query(ll n) //求长度为n的不包含任何模式串的串的种类数
    {              //等价于求不出现某些情况的方案数
        mat A = matpow(base, n);
        ll res = 0;
        for (int i = 0; i < sz; ++i)
            res = (res + A[0][i]) % mod;
        return res;
    }
    //求长度不超过n的至少包含一个模式串的串的种类数
    // 1+A+A^2+...+A^n <=> F(n)=A*F(n-1)+I
    ll query(ll n) // F(i)   A I    F(i-1)
    {              //  I     0 I      I
        mat A(sz + 1, vec(sz + 1));
        for (int i = 0; i < sz + 1; ++i)
            A[i][sz] = 1; // 增加一维，第sz列全部为1
        mat B(2, vec(2));
        B[0][0] = 26, B[0][1] = B[1][1] = 1;
        A = Pow(A, n), B = Pow(B, n);
        ull tot = B[0][0] + B[0][1], res = 0;
        for (int i = 0; i < sz + 1; ++i)
            res = (res + A[0][i]) % mod;
        return tot - res;
    }
    int query(const char *s) //返回主串中有多少模式串
    {
        int u = rt, res = 0;
        for (int i = 0; s[i]; ++i)
        {
            int c = idx(s[i]);
            u = ch[u][c];
            int v = u;                    //temp为模式串尾节点编号，val[temp]代表整个模式串
            while (v != rt && ~val[v]) //多次查询val[]不能变为-1
                res += val[v], val[v] = -1, v = f[v];
            /*while (v != rt) // val[u] = id;
            {                  //cnt[i]表示编号i的模式串出现的次数
                if (val[v])
                    ++cnt[val[v]];
                v = f[v];
            }*/
        }
        return res;
    }
} ac;
\end{lstlisting}
\subsection{后缀数组}
\begin{lstlisting}
char s[maxn];                         //空串rk[len]=0，sa[0]=len
int sa[maxn], rk[maxn], height[maxn]; //sa[i]表示将所有后缀排序后第i小的后缀的编号（即开始的位置）
//rk[i]表示后缀i的排名，height[i]=lcp(sa[i],sa[i-1])，即第i名的后缀与它前一名的后缀的最长公共前缀
struct Suffix_Array //倍增算法构造后缀数组,复杂度O(nlogn)
{
    int t[maxn], t2[maxn], c[maxn];
    void build_sa(int n, int m) //n为字符串的长度,字符集的值为0~m-1
    {
        ++n;
        int *x = t, *y = t2;
        //基数排序
        for (int i = 0; i < m; ++i)
            c[i] = 0;
        for (int i = 0; i < n; ++i)
            ++c[x[i] = s[i]];
        for (int i = 1; i < m; ++i)
            c[i] += c[i - 1];
        for (int i = n - 1; i >= 0; --i)
            sa[--c[x[i]]] = i;
        for (int k = 1; k <= n; k <<= 1) //直接利用sa数组排序第二关键字
        {
            int p = 0;
            for (int i = n - k; i < n; ++i)
                y[p++] = i;
            for (int i = 0; i < n; ++i)
                if (sa[i] >= k)
                    y[p++] = sa[i] - k;
            //基数排序第一关键字
            for (int i = 0; i < m; ++i)
                c[i] = 0;
            for (int i = 0; i < n; ++i)
                c[x[y[i]]]++;
            for (int i = 1; i < m; ++i)
                c[i] += c[i - 1];
            for (int i = n - 1; ~i; --i)
                sa[--c[x[y[i]]]] = y[i];
            //根据sa和y数组计算新的x数组
            swap(x, y);
            p = 1;
            x[sa[0]] = 0;
            for (int i = 1; i < n; i++)
                x[sa[i]] = y[sa[i - 1]] == y[sa[i]] && y[sa[i - 1] + k] == y[sa[i] + k] ? p - 1 : p++;
            if (p >= n)
                break; //以后即使继续倍增，sa也不会改变，推出
            m = p;     //下次基数排序的最大值
        }
        --n;
        int k = 0;
        for (int i = 0; i <= n; ++i)
            rk[sa[i]] = i;
        for (int i = 0; i < n; ++i)
        {
            if (k)
                --k;
            int j = sa[rk[i] - 1];
            while (s[i + k] == s[j + k])
                ++k;
            height[rk[i]] = k;
        }
    }
};
int dp[maxn][30];
void initrmq(int n)
{
    for (int i = 1; i <= n; i++)
        dp[i][0] = height[i];
    for (int j = 1; (1 << j) <= n; j++)
        for (int i = 1; i + (1 << j) - 1 <= n; i++)
            dp[i][j] = min(dp[i][j - 1], dp[i + (1 << (j - 1))][j - 1]);
}
int rmq(int l, int r)
{
    int k = 31 - __builtin_clz(r - l + 1);
    return min(dp[l][k], dp[r - (1 << k) + 1][k]);
}
int lcp(int a, int b) // 求两个后缀的最长公共前缀
{
    a = rk[a], b = rk[b];
    if (a > b)
        swap(a, b);
    return rmq(a + 1, b);
}
\end{lstlisting}
\subsection{后缀自动机}
后缀自动机（Suffix Automation）与AC自动机一样有一个基本性质：从根出发，走到每一个终止节点的路径恰好是所有的字符串（后缀自动机的字符串特指后缀），且保证不重不漏
\begin{lstlisting}
struct SAM
{ //每个状态v对应一个或多个字符串，记longest(v)是其中最长者，len(v)是其长度
    int len[maxn << 1], fa[maxn << 1], ch[maxn << 1][26];
    //last为未加入此字符前最长的前缀（整个串）所属的节点的编号
    int sz, rt, last; //sz为当前后缀自动机节点的总数
    int newnode(int x = 0)
    {
        len[sz] = x;
        fa[sz] = -1;
        memset(ch[sz], -1, sizeof(ch[sz]));
        return sz++;
    }
    void init() { sz = last = 0, rt = newnode(); }
    void reset() { last = 0; }
    void extend(int c) //for (int i = 0; i < s[i]; ++i)
    {                  //    sam.extend(s[i] - 'a');
        int np = newnode(len[last] + 1);
        int p = last;
        while (p != -1 && ch[p][c] == -1)
            ch[p][c] = np, p = fa[p];
        if (p == -1)
            fa[np] = rt;
        else
        {
            int q = ch[p][c];
            if (len[p] + 1 == len[q])
                fa[np] = q;
            else
            {
                int nq = newnode(len[p] + 1);
                memcpy(ch[nq], ch[q], sizeof(ch[q]));
                fa[nq] = fa[q], fa[q] = fa[np] = nq;
                while (p != -1 && ch[p][c] == q)
                    ch[p][c] = nq, p = fa[p];
            }
        }
        last = np;
    }

    int num[maxn << 1]; //每个结点所代表的字符串的出现次数
    int topcnt[maxn], topsam[maxn << 1];
    void build(const char *s)
    { // 加入串后拓扑排序
        memset(topcnt, 0, sizeof(topcnt));
        for (int i = 0; i < sz; ++i)
            topcnt[len[i]]++;
        for (int i = 0; i < maxn - 1; ++i)
            topcnt[i + 1] += topcnt[i];
        for (int i = 0; i < sz; ++i)
            topsam[--topcnt[len[i]]] = i;
        int u = rt;
        for (int i = 0; s[i]; i++)
            num[u = ch[u][s[i] - 'a']] = 1;
        for (int i = sz - 1; ~i; --i)
        {
            int u = topsam[i];
            if (~fa[u])
                num[fa[u]] += num[u];
        }
    }

} sam;
\end{lstlisting}
\subsection{回文自动机}
\begin{lstlisting}
struct Palindromic_Tree //每个节点i(从2开始，不包括0、1)代表一种本质不同的回文串
{                       //ch[i][ch]表示在回文串i两边添加字符ch后形成的新回文串编号
    int ch[maxn][26], f[maxn], s[maxn];
    int len[maxn];   //len[i]表示回文串i的长度
    ll cnt[maxn];    //cnt[i]表示回文串i出现的次数(调用count()后)
    int num[maxn];   //表示以节点i表示的最长回文串的最右端点为回文串结尾的回文串个数
    int last, sz, n; //sz-2表示本质不同的字符串的个数
    int newnode(int x)
    {
        memset(ch[sz], 0, sizeof(ch[sz]));
        cnt[sz] = num[sz] = 0, len[sz] = x;
        return sz++;
    }
    void init()
    {
        sz = 0;
        newnode(0), newnode(-1);
        last = n = 0, s[0] = -1, f[0] = 1;
    }
    int get_fail(int u)
    {
        while (s[n - len[u] - 1] != s[n])
            u = f[u];
        return u;
    }
    void add(int c, int pos) //for (int i = 0; s[i]; ++i)
    {                        //    pam.add(s[i] - 'a', i);
        s[++n] = c;
        int u = get_fail(last); //通过上一个回文串找这个回文串的匹配位置
        if (!ch[u][c])          //如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串
        {                       //回文串np由其最长回文子串u在两边添加两个相同的字符构成
            int np = newnode(len[u] + 2);
            //新回文串在原串的位置[pos-len[np] , pos]
            f[np] = ch[get_fail(f[u])][c];
            num[np] = num[f[np]] + 1;
            ch[u][c] = np;
        }
        last = ch[u][c];
        ++cnt[last];
    }
    void query()
    {
        for (int i = sz - 1; i >= 0; --i)
            cnt[f[i]] += cnt[i];
    }
} pam;
\end{lstlisting}
\subsection{Hash}
用哈希法判断一个字符串是否是另一个字符串的字串？


设字符串 $S=s_1s_2...s_m$，定义哈希函数 $$H(S)=(s_1 * b^{m-1} + s_2 * b^{m-2} + s_3 * b^{m-3} +...+ s_m * b^0) mod h$$ 其中b是基数，相当于把字符串看作b进制数
则 $H(S[k+1...k+m])=(H(S[k...k+m-1])*b - s_k * b^m + s_{k+m}) mod h$
\begin{lstlisting}
typedef unsigned long long ull;
const ull seed_Pool[] = {146527, 19260817};
const ull mod_Pool[] = {1000000007, 998244353};
ull seed = seed_Pool[0], mod = mod_Pool[0];
ull p[maxLen], h[maxLen];

void init(int n)
{
    p[0] = 1;
    for (int i = 1; i <= n; ++i)
        p[i] = p[i - 1] * seed % mod;
}
void Hash(const string &s)
{
    int n = s.length();
    h[0] = 0;
    for (int i = 1; i <= n; ++i)
        h[i] = (h[i - 1] * seed % mod + s[i - 1]) % mod;
}
//获取[l,r)子串的哈希值
ull get(int l, int r)
{
    return (h[r] - h[l] * p[r - l] % mod + mod) % mod;
}
//获取以l开始长度为m的哈希值
ull substr(int l, int m) { return get(l, l + m); }
\end{lstlisting}
\subsection{序列自动机}
\begin{lstlisting}
int nxt[maxn][26];           //nxt[i][j]表示在原串s第i位之后字符j第一次出现的位置
int now[26];                 //now[i]表示第i个字母在原串中从后向前最晚出现的位置
void init(char s[], int len) //序列自动机（下标从1开始 nxt[0][j]）
{
    memset(now, -1, sizeof(now));
    for (int i = len; i >= 0; --i) //从后往前处理
    {
        for (int j = 0; j < 26; ++j)
            nxt[i][j] = now[j];
        now[s[i] - 'a'] = i; //用当前字符更新当前字符在原串中从后向前最晚出现的位置
    }
}
\end{lstlisting}
\subsection{最小表示法}
最小/最大表示法
\begin{lstlisting}
void min_max_express(char s[], int len, char t[], bool flag) //flag=true为最小表示法
{
    int i = 0, j = 1, k = 0; //i指向字符串最小的位置，j为比较指针，k表示str[i]与str[j]相等时一次移动几个
    while (k < len && i < len && j < len)
    {
        int temp = s[(i + k) % len] - s[(j + k) % len];
        if (temp == 0)
            ++k;
        else
        {
            if ((flag ? temp > 0 : temp <= 0))
                i = i + k + 1;
            else
                j = j + k + 1;
            if (i == j)
                ++i;
            k = 0;
        }
    }
    int id = min(i, j);
    for (int p = 0; p < len; ++p)
        t[p] = s[(id + p) % len];
    t[len] = '\0';
}
\end{lstlisting}
\clearpage\section{Data Structure}
\subsection{Binary Indexed Tree}
\subsubsection{单点更新+区间查询}
$O(\log n)$查询和修改数组的前缀和
已知一个数列，你需要进行下面两种操作：
1.将某一个数加上x   2.求出某区间每一个数的和
注意下标应从1开始
\begin{lstlisting}
struct BIT
{
    ll n, bit[maxn]; //n为数组下标，求逆序对时n为a[i]的最大值
    void init(int n)
    {
        this->n = n;
        int x;
        for (int i = 1; i <= n; ++i)
            scanf("%d", &x), add(i, x);
    } //返回x的二进制表示中最低的一位1所表示的数
    int lowbit(int x) { return x & -x; }
    void add(int pos, ll x)
    { //修改为x: add(pos, x - a[pos]), a[pos] = x;
        while (pos <= n)
            bit[pos] += x, pos += lowbit(pos);
    }
    ll query(int pos) //区间[1,pos]的和
    {                 //[x,y]: sum(y) - sum(x - 1);
        ll res = 0;
        while (pos > 0)
            res += bit[pos], pos -= lowbit(pos);
        return res;
    }
};
\end{lstlisting}
\subsubsection{区间更新+单点查询}
已知一个数列，你需要进行下面两种操作：
1.将某区间每一个数加上x   2.求出某一个数的值
\begin{lstlisting}
struct BIT
{
    int n, bit[maxn];
    void init(int n)
    {
        this->n = n;
        ll last = 0, now;
        for (int i = 1; i <= n; ++i)
        {
            scanf("%lld", &now);
            add(i, now - last); //a[i] - a[i-1]
            last = now;
        }
    }
    int lowbit(int x) { return x & -x; }
    void add(int pos, int x)
    {
        while (pos <= n)
            bit[pos] += x, pos += lowbit(pos);
    }
    void update(int x, int y, int val)
    {
        add(x, val);      //d[x]' = a[x]-a[x-1] = d[x]+k
        add(y + 1, -val); //d[y+1]' = a[y+1]-a[y] = d[y+1]-k
    }
    ll query(int pos) //[x,y]: sum(y) - sum(x - 1);
    {
        ll res = 0;
        while (pos > 0)
            res += bit[pos], pos -= lowbit(pos);
        return res;
    }
};
\end{lstlisting}
\subsection{Segment Tree}
\subsubsection{线段树}
线段树(Segment Tree)可以在 $O(\log n)$ 的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作
\begin{lstlisting}
#define lson rt << 1     //左儿子
#define rson rt << 1 | 1 //右儿子
#define Lson l, m, lson
#define Rson m + 1, r, rson
ll a[maxn << 2], lazy[maxn << 2];
//用儿子节点的信息更新父亲节点：a[rt] = sum/max/min(a[lson] + a[rson]);
inline void pushup(int rt) { a[rt] = a[lson] + a[rson]; }
void build(int l, int r, int rt) //rt表示当前节点的编号，(l,r)表示当前节点管辖的区间
{
    //lazy[rt] = 0;
    if (l == r) //递归到L==r时表示已经到达了叶子结点
    {
        scanf("%lld", &a[rt]);
        return;
    }
    int m = (l + r) >> 1;
    build(Lson), build(Rson);
    pushup(rt); //因为要通过子节点来维护父亲节点，所以pushup的操作应当在回溯时
}
// 单点更新
void update(int x, int val, int l, int r, int rt)
{
    if (l == r)
    {
        a[rt] += val;
        return;
    }
    int m = (l + r) >> 1;
    if (x <= m)
        update(x, val, Lson);
    else
        update(x, val, Rson);
    pushup(rt);
}
/* 区间更新
void pushdown(int rt, int len)
{
    if (lazy[rt])
    {
        ll lz = lazy[rt];
        lazy[rt] = 0;
        lazy[lson] += lz, lazy[rson] += lz;
        a[lson] += lz * (len - len / 2), a[rson] += lz * (len >> 1);
    }
}
void update(int x, int y, int val, int l, int r, int rt)
{
    if (x <= l && y >= r)
    {
        a[rt] += (r - l + 1) * val;
        lazy[rt] += val;
        return;
    }
    pushdown(rt, r - l + 1);
    int m = (l + r) >> 1;
    if (x <= m)
        update(x, y, val, Lson);
    if (y > m)
        update(x, y, val, Rson);
    pushup(rt);
}
*/
ll query(int x, int y, int l, int r, int rt)
{
    if (x <= l && y >= r)
        return a[rt];
    //pushdown(rt, r - l + 1);
    int m = (l + r) >> 1;
    ll res = 0; //res = sum(0)/max(-INF)/min(INF)(res, query(x, y, Lson));
    if (x <= m)
        res += query(x, y, Lson);
    if (y > m)
        res += query(x, y, Rson);
    return res;
}

scanf("%d", &n);
build(1, n, 1); //建树
scanf("%d%d%d", &x, &y, &val);
if (x > y)
    swap(x, y);
query(x, y, 1, n, 1));
update(x, y, val, 1, n, 1);
\end{lstlisting}
\subsubsection{乘法更新}
\begin{lstlisting}
ll a[maxn << 2], lazy[maxn << 2], lazy2[maxn << 2];
int mod;
inline void pushup(int rt) { a[rt] = (a[lson] + a[rson]) % mod; }
void build(int l, int r, int rt)
{
    lazy[rt] = 0, lazy2[rt] = 1;
    if (l == r)
    {
        scanf("%lld", &a[rt]);
        return;
    }
    int m = (l + r) >> 1;
    build(Lson), build(Rson);
    pushup(rt);
}
void pushdown(int rt, int len)
{
    ll lz = lazy[rt], lz2 = lazy2[rt];
    lazy2[rt] = 1, lazy[rt] = 0;
    a[lson] = (a[lson] * lz2 + lz * (len - len / 2)) % mod;
    a[rson] = (a[rson] * lz2 + lz * (len >> 1)) % mod;
    lazy[lson] = (lazy[lson] * lz2 + lz) % mod;
    lazy[rson] = (lazy[rson] * lz2 + lz) % mod;
    lazy2[lson] = lazy2[lson] * lz2 % mod;
    lazy2[rson] = lazy2[rson] * lz2 % mod;
}
void update(int x, int y, int val, int l, int r, int rt) //加法更新
{
    if (x <= l && y >= r)
    {
        a[rt] = (a[rt] + ((r - l + 1) * val)) % mod;
        lazy[rt] = (lazy[rt] + val) % mod;
        return;
    }
    pushdown(rt, r - l + 1);
    int m = (l + r) >> 1;
    if (x <= m)
        update(x, y, val, Lson);
    if (y > m)
        update(x, y, val, Rson);
    pushup(rt);
}
void update2(int x, int y, int val, int l, int r, int rt) //乘法更新
{
    if (x <= l && y >= r)
    {
        a[rt] = (a[rt] * val) % mod;
        lazy2[rt] = (lazy2[rt] * val) % mod;
        lazy[rt] = (lazy[rt] * val) % mod;
        return;
    }
    pushdown(rt, r - l + 1);
    int m = (l + r) >> 1;
    if (x <= m)
        update2(x, y, val, Lson);
    if (y > m)
        update2(x, y, val, Rson);
    pushup(rt);
}
ll query(int x, int y, int l, int r, int rt)
{
    if (x <= l && y >= r)
        return a[rt];
    pushdown(rt, r - l + 1);
    int m = (l + r) >> 1;
    ll res = 0;
    if (x <= m)
        res += query(x, y, Lson);
    if (y > m)
        res += query(x, y, Rson);
    return res % mod;
}
\end{lstlisting}
\subsection{Splay}
\begin{lstlisting}
#define key_value ch[ch[root][1]][0]
struct Splay
{
    int a[maxn];
    int sz[maxn], ch[maxn][2], fa[maxn];
    int key[maxn], rev[maxn];
    int root, tot;
    int stk[maxn], top;
    void init(int n)
    {
        tot = 0, top = 0;
        root = newnode(0, -1);
        ch[root][1] = newnode(root, -1);
        for (int i = 0; i < n; i++)
            a[i] = i + 1;
        key_value = build(0, n - 1, ch[root][1]);
        pushup(ch[root][1]);
        pushup(root);
    }
    int newnode(int p = 0, int k = 0)
    {
        int x = top ? stk[top--] : ++tot;
        fa[x] = p;
        sz[x] = 1;
        ch[x][0] = ch[x][1] = 0;
        key[x] = k;
        rev[x] = 0;
        return x;
    }
    void pushdown(int x)
    {
        if (rev[x])
        {
            swap(ch[x][0], ch[x][1]);
            if (ch[x][0])
                rev[ch[x][0]] ^= 1;
            if (ch[x][1])
                rev[ch[x][1]] ^= 1;
            rev[x] = 0;
        }
    }
    void pushup(int x) { sz[x] = sz[ch[x][0]] + sz[ch[x][1]] + 1; }
    void rotate(int x, int d)
    {
        int y = fa[x];
        pushdown(y), pushdown(x);
        ch[y][d ^ 1] = ch[x][d];
        fa[ch[x][d]] = y;
        if (fa[y])
            ch[fa[y]][ch[fa[y]][1] == y] = x;
        fa[x] = fa[y];
        ch[x][d] = y;
        fa[y] = x;
        pushup(y);
    }
    void splay(int x, int goal = 0)
    {
        pushdown(x);
        while (fa[x] != goal)
        {
            if (fa[fa[x]] == goal)
                rotate(x, ch[fa[x]][0] == x);
            else
            {
                int y = fa[x];
                int d = ch[fa[y]][0] == y;
                ch[y][d] == x ? rotate(x, d ^ 1) : rotate(y, d);
                rotate(x, d);
            }
        }
        pushup(x);
        if (goal == 0)
            root = x;
    }
    int kth(int r, int k)
    {
        pushdown(r);
        int t = sz[ch[r][0]] + 1;
        if (t == k)
            return r;
        return t > k ? kth(ch[r][0], k) : kth(ch[r][1], k - t);
    }
    int build(int l, int r, int p)
    {
        if (l > r)
            return 0;
        int m = (l + r) >> 1;
        int x = newnode(p, a[m]);
        ch[x][0] = build(l, m - 1, x);
        ch[x][1] = build(m + 1, r, x);
        pushup(x);
        return x;
    }
    void select(int l, int r)
    {
        splay(kth(root, l), 0);
        splay(kth(ch[root][1], r - l + 2), root);
    }
    // 各种操作
};
\end{lstlisting}
\subsection{主席树}
静态查询区间第 $k$ 小的值
\begin{lstlisting}
#define Lson l, m, lson[x], lson[y]
#define Rson m + 1, r, rson[x], rson[y]
const int maxn = ;
int a[maxn], rt[maxn];
int cnt;
int lson[maxn << 5], rson[maxn << 5], sum[maxn << 5];
void update(int pos, int l, int r, int &x, int y)
{
    lson[++cnt] = lson[y], rson[cnt] = rson[y], sum[cnt] = sum[y] + 1, x = cnt;
    if (l == r)
        return;
    int m = (l + r) >> 1;
    if (pos <= m)
        update(pos, Lson);
    else
        update(pos, Rson);
}
int query(int l, int r, int x, int y, int k)
{
    if (l == r)
        return l;
    int m = (l + r) >> 1;
    int s = sum[lson[y]] - sum[lson[x]]; //左子树的个数
    if (s >= k)
        return query(Lson, k);
    else
        return query(Rson, k - s);
}
int kth(int l, int r, int k, int n)
{
    return v[query(1, n, rt[l - 1], rt[r], k) - 1];
}
void init()
{
    v.clear(), cnt = 0;
    rt[0] = sum[0] = 0;
}

for (int i = 1; i <= n; ++i)
    scanf("%d", a + i), v.push_back(a[i]);
/* ---  离散化  ---- */
for (int i = 1; i <= n; ++i)
    update(getID(a[i]), 1, n, rt[i], rt[i - 1]);
res = kth(l, r, k, n);
\end{lstlisting}
\subsection{Sparse Table}
一维RMQ
\begin{lstlisting}
int a[maxn], dp[maxn][20];
void init(int n)
{
    for (int i = 1; i <= n; i++)
    {
        scanf("%d", &a[i]);
        dp[i][0] = a[i];
    }
    for (int j = 1; (1 << j) <= n; j++)
        for (int i = 1; i + (1 << j) - 1 <= n; i++)
            dp[i][j] = max(dp[i][j - 1], dp[i + (1 << (j - 1))][j - 1]);
}
int rmq(int l, int r, int op) // 返回[l,r]最大值
{
    int k = 0; //int k = 31 - __builtin_clz(r - l + 1);
    while ((1 << (k + 1)) <= r - l + 1)
        ++k;
    return max(dp[l][k], dp[r - (1 << k) + 1][k]);
}
\end{lstlisting}
二维RMQ
\begin{lstlisting}
void init(int n, int m)
{
    for (int i = 0; (1 << i) <= n; i++)
        for (int j = 0; (1 << j) <= m; j++)
        {
            if (i == 0 && j == 0)
                continue;
            for (int row = 1; row + (1 << i) - 1 <= n; row++)
                for (int col = 1; col + (1 << j) - 1 <= m; col++)
                    if (i)
                        dp[row][col][i][j] = max(dp[row][col][i - 1][j], dp[row + (1 << (i - 1))][col][i - 1][j]);
                    else
                        dp[row][col][i][j] = max(dp[row][col][i][j - 1], dp[row][col + (1 << (j - 1))][i][j - 1]);
        }
}
int rmq(int x1, int y1, int x2, int y2)
{
    int kx = 31 - __builtin_clz(x2 - x1 + 1);
    int ky = 31 - __builtin_clz(y2 - y1 + 1);
    int m1 = dp[x1][y1][kx][ky];
    int m2 = dp[x2 - (1 << kx) + 1][y1][kx][ky];
    int m3 = dp[x1][y2 - (1 << ky) + 1][kx][ky];
    int m4 = dp[x2 - (1 << kx) + 1][y2 - (1 << ky) + 1][kx][ky];
    return max({m1, m2, m3, m4});
}
\end{lstlisting}
\subsection{树链剖分}
Heavy-Light Decomposition
轻重链/长链剖分
\begin{lstlisting}
int temp[maxn];
int sumv[maxn << 2], maxv[maxn << 2], lazy[maxn << 2];
//build函数中：if (l == r) { sumv[rt]/maxv[rt] = temp[l]; return; }

struct HLD
{
    int n, dfs_clock;
    int sz[maxn], top[maxn], son[maxn], dep[maxn], fa[maxn], id[maxn];
    vector<int> G[maxn];
    // vector<pair<PII, int>> edges; 维护边权时，将其下放为儿子结点的点权
    void init(int n)
    {
        this->n = n, memset(son, -1, sizeof(son)), dfs_clock = 0;
        for (int i = 0; i <= n; i++)
            G[i].clear();
    }
    void add_edge(int u, int v) { G[u].push_back(v), G[v].push_back(u); }
    void dfs(int u, int f, int d) //u当前节点，f父亲，d深度
    {                             //标记每个点的深度、父亲、每个非叶子节点的子树大小
        dep[u] = d, fa[u] = f, sz[u] = 1;
        for (auto &v : G[u])
        {
            if (v == f) //若为父亲则continue
                continue;
            dfs(v, u, d + 1); //dfs其儿子
            sz[u] += sz[v];   //把它的儿子数加到它身上
            if (son[u] == -1 || sz[v] > sz[son[u]])
                son[u] = v; //标记每个非叶子节点的重儿子编号
        }
    }
    void link(int u, int t)              //u当前节点，t(top)当前链的最顶端的节点
    {                                    //这个点所在链的顶端
        top[u] = t, id[u] = ++dfs_clock; //标记每个点的新编号
        if (son[u] == -1)                //如果没有儿子则返回
            return;
        link(son[u], t); //按先处理重儿子，再处理轻儿子的顺序递归处理
        for (auto &v : G[u])
            if (v != son[u] && v != fa[u])
                link(v, v); //对于每一个轻儿子都有一条从它自己开始的链
    }
    void build_tree() // 数据结构相关操作，一般使用线段树或者树状数组
    {
        for (int i = 1; i <= n; ++i)
            scanf("%d", &temp[id[i]]);
        build(1, n, 1);
    }
    int query_path(int u, int v) //更新只需把query函数换成update函数
    {
        int res = 0;
        while (top[u] != top[v]) //当两个点不在同一条链上
        {
            if (dep[top[u]] < dep[top[v]]) //把u点改为所在链顶端的深度更深的那个点
                swap(u, v);
            res = sum / max / min(res, query(id[top[u]], id[u], 1, n, 1)); //res加上u点到u所在链顶端 这一段区间的点权和
            u = fa[top[u]];                                                //把u跳到u所在链顶端的那个点的上面一个点
        }                                                                  //直到两个点处于一条链上
        if (dep[u] > dep[v])                                               //把u点改为深度更深的那个点
            swap(u, v);
        res = sum / max / min(res, query(id[u], id[v], 1, n, 1)); //这时再加上此时两个点的区间和即可
        /* 边权
        if (u == v) return ret;
        if (dep[u] > dep[v]) swap(u, v);
        ret += query(id[son[u]], id[v]);
        */
        return res;
    }
    int query_son(int u) //查询以u为根节点的子树
    {
        return query(id[u], id[u] + sz[u] - 1, 1, n, 1);
    }
};

HLD T;
T.init(n);
/* 输入边信息 */
T.dfs(root, -1, 1);
T.link(root, root);
T.build_tree(); //建树在最后
\end{lstlisting}
\subsection{动态树}
（Link-Cut Tree）动态维护一个森林
\begin{lstlisting}
struct LCT
{
    int val[maxn], sum[maxn]; // 基于点权
    int rev[maxn], ch[maxn][2], fa[maxn];
    int stk[maxn];
    inline void init(int n)
    { // 初始化点权
        for (int i = 1; i <= n; i++)
            scanf("%d", val + i);
        for (int i = 1; i <= n; i++)
            fa[i] = ch[i][0] = ch[i][1] = rev[i] = 0;
    }
    inline bool isroot(int x) { return ch[fa[x]][0] != x && ch[fa[x]][1] != x; }
    inline bool get(int x) { return ch[fa[x]][1] == x; }
    void pushdown(int x)
    {
        if (!rev[x])
            return;
        swap(ch[x][0], ch[x][1]);
        if (ch[x][0])
            rev[ch[x][0]] ^= 1;
        if (ch[x][1])
            rev[ch[x][1]] ^= 1;
        rev[x] ^= 1;
    }
    void pushup(int x) { sum[x] = val[x] + sum[ch[x][0]] + sum[ch[x][1]]; }
    void rotate(int x)
    {
        int y = fa[x], z = fa[fa[x]], d = get(x);
        if (!isroot(y))
            ch[z][get(y)] = x;
        fa[x] = z;
        ch[y][d] = ch[x][d ^ 1], fa[ch[y][d]] = y;
        ch[x][d ^ 1] = y, fa[y] = x;
        pushup(y), pushup(x);
    }
    void splay(int x)
    {
        int top = 0;
        stk[++top] = x;
        for (int i = x; !isroot(i); i = fa[i])
            stk[++top] = fa[i];
        for (int i = top; i; i--)
            pushdown(stk[i]);
        for (int f; !isroot(x); rotate(x))
            if (!isroot(f = fa[x]))
                rotate(get(x) == get(f) ? f : x);
    }
    void access(int x)
    {
        for (int y = 0; x; y = x, x = fa[x])
            splay(x), ch[x][1] = y, pushup(x);
    }
    int find(int x)
    {
        access(x), splay(x);
        while (ch[x][0])
            x = ch[x][0];
        return x;
    }
    void makeroot(int x) { access(x), splay(x), rev[x] ^= 1; }
    void link(int x, int y) { makeroot(x), fa[x] = y, splay(x); }
    void cut(int x, int y) { makeroot(x), access(y), splay(y), fa[x] = ch[y][0] = 0; }
    void update(int x, int v) { val[x] = v, access(x), splay(x); }
    int query(int x, int y)
    {
        makeroot(y), access(x), splay(x);
        return sum[x];
    }
};
\end{lstlisting}
\subsection{Virtual Tree}
\begin{lstlisting}
vector<int> vtree[maxn];
void build(vector<int>& vec)
{
    sort(vec.begin(), vec.end(), [&](int x, int y) { return dfn[x] < dfn[y]; });
    static int s[maxn];
    int top = 0;
    s[top] = 0;
    vtree[0].clear();
    for (auto& u : vec)
    {
        int vlca = lca(u, s[top]);
        vtree[u].clear();
        if (vlca == s[top])
            s[++top] = u;
        else
        {
            while (top && dep[s[top - 1]] >= dep[vlca])
            {
                vtree[s[top - 1]].push_back(s[top]);
                top--;
            }
            if (s[top] != vlca)
            {
                vtree[vlca].clear();
                vtree[vlca].push_back(s[top--]);
                s[++top] = vlca;
            }
            s[++top] = u;
        }
    }
    for (int i = 0; i < top; ++i) vtree[s[i]].push_back(s[i + 1]);
}
\end{lstlisting}
\subsection{笛卡尔树}
Cartesian Tree
\begin{lstlisting}
int lson[maxn], rson[maxn], fa[maxn];
void build(int n)
{
    stack<int> s;
    for (int i = 0; i < n; ++i)
    {
        int last = -1;
        while (!s.empty() && a[i] < a[s.top()]) // < 小根堆；> 大根堆
            last = s.top(), s.pop();
        if (!s.empty())
            rson[s.top()] = i, fa[i] = s.top();
        lson[i] = last;
        if (last != -1)
            fa[last] = i;
        s.push(i);
    }
}
\end{lstlisting}
\subsection{Others}
\subsubsection{单调队列}
给出一个长度为n的数组，求每k个连续的数中的最大值和最小值
\begin{lstlisting}
deque<int> q;
void getmax(int n, int k)
{
    for (int i = 1, j = 1; i + k - 1 <= n; ++i)
    {
        while (j <= i + k - 1)
        {
            while (!q.empty() && a[q.back()] < a[j]) // >
                q.pop_back();
            q.push_back(j++);
        }
        while (q.front() < i)
            q.pop_front();
        cout << a[q.front()]; //区间[i,i+k-1]的最大/小值
    }
}
\end{lstlisting}
二维滑动窗口最大/小值
首先，分别计算1维滑动窗口最大/小的矩阵的每一行，然后在所得矩阵上计算每列的一维滑动窗口最大/小值
可推广至n维滑动窗口
\begin{lstlisting}
ll getmax(int n, int m, int k) //k*k大小的窗口
{
    deque<int> q;
    for (int row = 1; row <= n; ++row)
    {
        q.clear();
        for (int i = 1, j = 1; i + k - 1 <= m; ++i)
        {
            while (j <= i + k - 1)
            {
                while (!q.empty() && A[row][q.back()] < A[row][j]) // >
                    q.pop_back();
                q.push_back(j++);
            }
            while (q.front() < i)
                q.pop_front();
            res[row][i] = A[row][q.front()];
        }
    }
    for (int col = 1; col <= m - k + 1; ++col)
    {
        q.clear();
        for (int i = 1, j = 1; i + k - 1 <= n; ++i)
        {
            while (j <= i + k - 1)
            {
                while (!q.empty() && res[q.back()][col] < res[j][col]) // >
                    q.pop_back();
                q.push_back(j++);
            }
            while (q.front() < i)
                q.pop_front();
            cout << res[q.front()][col];
        }
    }
    return ans;
}
\end{lstlisting}
\subsubsection{单调栈}
\begin{lstlisting}
stack<int> s;
for (int i = 1; i <= n; ++i)
{
    while (!s.empty() && h[s.top()] < h[i])
    {
        res[s.top()] = i - s.top();
        s.pop();
    }
    s.push(i);
}
while (!s.empty())
{
    res[s.top()] = n - s.top() + 1;
    s.pop();
}
\end{lstlisting}
\clearpage\section{Graph Theory}
\subsection{Shortest Path}
\subsubsection{Floyd Warshall}
时间复杂度 $O(n^3)$ ，空间复杂度 $O(n^2)$
\begin{lstlisting}
struct Floyd // 任意两点间的最短路径
{
    int n;                 //顶点数
    int dis[max_v][max_v]; //dis[u][v]表示边e={u,v}的权值（不存在时设为INF，不过d[i][i]=0）
    void init(int V)
    {
        this->n = V;
        for (int i = 0; i < n; ++i)
            for (int j = 0; j < n; ++j)
                dis[i][j] = (i == j) ? 0 : INF;
    }
    void AddEdge(int from, int to, int dist) { dis[from][to] = dist; } //无向图需调用两次
    //dis[k][i][j] = min(dis[k-1][i][j], dis[k-1][i][k] + dis[k-1][k][j]);
    void floyd()
    {
        for (int k = 0; k < n; ++k)
            for (int i = 0; i < n; ++i)
                for (int j = 0; j < n; ++j)
                    dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);
    }
};
\end{lstlisting}
如果是一个没有边权的图，把相连的两点间的距离设为dis[i][j]=true，不相连的两点设为dis[i][j]=false
若某一个顶点与其余n-1个顶点都相连，则其排名是确定的
\begin{lstlisting}
bool dis[max_v][max_v];
void floyd(int n) //判断一张图中的任意两点是否相连
{
    for (int k = 0; k < n; ++k)
        for (int i = 0; i < n; ++i)
            for (int j = 0; j < n; ++j)
                dis[i][j] |= dis[i][k] & dis[k][j];
}
\end{lstlisting}
最大/最小环（dis[][]全部初始化为INF）
\begin{lstlisting}
void floyd()
{
    for (int k = 0; k < V; ++k)
        for (int i = 0; i < V; ++i)
            for (int j = 0; j < V; ++j)
                dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);
    int res = 0;
    for (int i = 0; i < V; ++i)
        res = min(res, dis[i][i]);
    return res;
}
\end{lstlisting}
\subsubsection{Dijkstra}
复杂度 $O((n+m) \log m)$
\begin{lstlisting}
struct Edge
{
    int from, to, dist;
    Edge(int u, int v, int d) : from(u), to(v), dist(d) {}
};
struct HeapNode
{
    int dist, u;
    bool operator<(const HeapNode &rhs) const { return dist > rhs.dist; }
};
struct Dijkstra
{
    int n, m;             // 顶点数和边数
    vector<Edge> edges;   // 边列表
    vector<int> G[max_v]; // 每个节点出发的边号（从0开始编号，若题目从1开始编号，则输入时要减一）
    bool vis[max_v];      // 是否已永久标号
    int dis[max_v];       // s到各点的距离
    int p[max_v];         // 最短路中的一条边
    void init(int V)      // 初始化，建立V个顶点的图
    {
        this->n = V;
        for (int i = 0; i < n; ++i)
            G[i].clear(); // 清空邻接表
        edges.clear();    // 清空边表
    }
    void AddEdge(int from, int to, int dist)
    { //无向图需调用两次
        edges.emplace_back(from, to, dist);
        G[from].push_back(edges.size() - 1);
    }
    void dijkstra(int s)
    {
        for (int i = 0; i < n; ++i)
            dis[i] = INF;
        memset(vis, 0, sizeof(vis));
        priority_queue<HeapNode> q;
        q.push({0, s});
        dis[s] = 0;
        while (!q.empty())
        {
            auto x = q.top();
            q.pop();
            int u = x.u;
            if (vis[u])
                continue;
            vis[u] = true;
            for (auto &id : G[u])
            {
                Edge &e = edges[id];
                if (dis[e.to] > dis[u] + e.dist)
                {
                    dis[e.to] = dis[u] + e.dist;
                    p[e.to] = id;
                    q.push({dis[e.to], e.to});
                }
            }
        }
    }
};
\end{lstlisting}
\subsubsection{Bellman Ford}
复杂度： $O(NM)$
\begin{lstlisting}
struct Edge
{
    int from, to, dist;
    Edge(int u, int v, int d) : from(u), to(v), dist(d) {}
};
struct BellmanFord
{
    int n, m;             // 顶点数和边数
    vector<Edge> edges;   // 边列表
    vector<int> G[max_v]; // 每个节点出发的边编号（从0开始编号，若题目从1开始编号，则输入时要减一）
    bool inq[max_v];      // 是否在队列中
    int dis[max_v];       // s到各个点的距离
    int p[max_v];         // 最短路中的上一条弧
    int cnt[max_v];       // 进队次数
    void init(int V)      // 初始化，建立V个顶点的图
    {
        this->n = V;
        for (int i = 0; i < V; i++)
            G[i].clear();
        edges.clear();
    }
    void AddEdge(int from, int to, int dist) //无向图需调用两次
    {
        edges.emplace_back(from, to, dist);
        G[from].push_back(edges.size() - 1);
    }
    bool bellmanford(int s) //如果返回false则存在负圈
    {
        queue<int> q;
        memset(inq, 0, sizeof(inq));
        memset(cnt, 0, sizeof(cnt));
        for (int i = 0; i < n; i++)
            dis[i] = INF;
        q.push(s);
        dis[s] = 0, inq[s] = true;
        while (!q.empty())
        {
            int u = q.front();
            q.pop();
            inq[u] = false;
            for (auto &id : G[u])
            {
                Edge &e = edges[id];
                if (dis[u] < INF && dis[e.to] > dis[u] + e.dist)
                {
                    dis[e.to] = dis[u] + e.dist;
                    p[e.to] = id;
                    if (!inq[e.to])
                    {
                        q.push(e.to);
                        inq[e.to] = true;
                        if (++cnt[e.to] > n)
                            return false;
                    }
                }
            }
        }
        return true;
    }
};
\end{lstlisting}
\subsection{Minimum Spanning Tree}
\subsubsection{Kruskal}
\begin{lstlisting}
struct Edge
{
    int from, to, dist;
    Edge(int u, int v, int d) : from(u), to(v), dist(d) {}
    bool operator<(const Edge &rhs) const { return dist < rhs.dist; }
};
struct Kruskal
{
    int n;
    int fa[max_v];
    vector<Edge> G;
    void init(int V)
    {
        this->n = V;
        for (int i = 0; i < n; ++i)
            fa[i] = i;
        G.clear();
    }
    int find(int x) { return x == fa[x] ? x : fa[x] = find(fa[x]); }
    void unite(int x, int y) { fa[find(x)] = find(y); }
    bool same(int x, int y) { return find(x) == find(y); }
    void AddEdge(int from, int to, int dist)
    {
        G.push_back(Edge{from, to, dist});
    }
    int kruskal() //不存在最小生成树时返回-1
    {
        sort(G.begin(), G.end()); //按照edge.cost的顺序从小到大排列
        int res = 0, cnt = 0;
        for (auto &e : G)
        {
            if (!same(e.from, e.to))
            {
                unite(e.from, e.to);
                ++cnt;
                res += e.dist; //res = sum/max/min(res,e.dist);
            }
        }
        return cnt == n - 1 ? res : -1; //最小生成树的边必为顶点数减一
    }
};
\end{lstlisting}
最大生成树
\begin{lstlisting}
bool operator<(const Edge &rhs) const { return dist > rhs.dist; }
\end{lstlisting}
从顶点1出发到达顶点n，求所有路径中边最小长度最大的
\begin{lstlisting}
for (int i = 0; i < G.size(); ++i)
{
    Edge &e = G[i];
    unite(e.from, e.to);
    if (same(0, n - 1))
        return e.dist;
}
\end{lstlisting}
求所有路径中边最大长度最小的，只需再修改重载小于号函数
\begin{lstlisting}
bool operator<(const Edge &rhs) const { return dist > rhs.dist; }
\end{lstlisting}
\subsubsection{Prim}
\begin{lstlisting}
int cost[max_v][max_v]; //cost[u][v]表示边e={u,v}的权值（不存在的设为INF，已存在的设为0）
struct Prim             //缺点：占用内存过大
{
    int n;           //顶点数
    int dis[max_v];  //从集合X出发的边到每个顶点的最小权值
    bool vis[max_v]; //顶点i是否包含在集合X中
    void init(int V) //顶点从0开始编号，若题目从1开始编号，则输入时要减一
    {
        this->n = V;
        for (int i = 0; i < n; ++i)
            dis[i] = INF, vis[i] = false;
        for (int i = 0; i < n; ++i)
            for (int j = 0; j < n; ++j)
                cost[i][j] = INF;
    }
    int prim()
    {
        dis[0] = 0;
        int res = 0;
        while (true)
        {
            int v = -1;
            for (int u = 0; u < n; ++u) //从不属于X的顶点中选取从X到其权值最小的顶点
                if (!vis[u] && (v == -1 || dis[u] < dis[v]))
                    v = u;
            if (v == -1)
                break;
            vis[v] = true; //把顶点v加入X
            res += dis[v]; //把边的长度加到结果里
            for (int u = 0; u < n; ++u)
                dis[u] = min(dis[u], cost[v][u]);
        }
        return res;
    }
};
\end{lstlisting}
\subsubsection{Zhu Liu}
固定根的最小树型图，邻接矩阵写法
\begin{lstlisting}
struct MDST
{
    int n;
    int w[maxn][maxn]; // 边权
    int vis[maxn];     // 访问标记，仅用来判断无解
    int ans;           // 计算答案
    int removed[maxn]; // 每个点是否被删除
    int cid[maxn];     // 所在圈编号
    int pre[maxn];     // 最小入边的起点
    int iw[maxn];      // 最小入边的权值
    int max_cid;       // 最大圈编号
    void init(int n)
    {
        this->n = n;
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++) w[i][j] = INF;
    }
    void AddEdge(int u, int v, int cost)
    {
        w[u][v] = min(w[u][v], cost); // 重边取权最小的
    }
    // 从s出发能到达多少个结点
    int dfs(int s)
    {
        vis[s] = 1;
        int ans = 1;
        for (int i = 0; i < n; i++)
            if (!vis[i] && w[s][i] < INF) ans += dfs(i);
        return ans;
    }
    // 从u出发沿着pre指针找圈
    bool cycle(int u)
    {
        max_cid++;
        int v = u;
        while (cid[v] != max_cid)
        {
            cid[v] = max_cid;
            v = pre[v];
        }
        return v == u;
    }
    // 计算u的最小入弧，入弧起点不得在圈c中
    void update(int u)
    {
        iw[u] = INF;
        for (int i = 0; i < n; i++)
            if (!removed[i] && w[i][u] < iw[u])
            {
                iw[u] = w[i][u];
                pre[u] = i;
            }
    }
    // 根结点为s，如果失败则返回false
    bool solve(int s)
    {
        memset(vis, 0, sizeof(vis));
        if (dfs(s) != n) return false;
        memset(removed, 0, sizeof(removed));
        memset(cid, 0, sizeof(cid));
        for (int u = 0; u < n; u++) update(u);
        pre[s] = s;
        iw[s] = 0; // 根结点特殊处理
        ans = max_cid = 0;
        for (;;)
        {
            bool have_cycle = false;
            for (int u = 0; u < n; u++)
                if (u != s && !removed[u] && cycle(u))
                {
                    have_cycle = true;
                    // 以下代码缩圈，圈上除了u之外的结点均删除
                    int v = u;
                    do
                    {
                        if (v != u) removed[v] = 1;
                        ans += iw[v];
                        // 对于圈外点i，把边i->v改成i->u（并调整权值）；v->i改为u->i
                        // 注意圈上可能还有一个v'使得i->v'或者v'->i存在，
                        // 因此只保留权值最小的i->u和u->i
                        for (int i = 0; i < n; i++)
                            if (cid[i] != cid[u] && !removed[i])
                            {
                                if (w[i][v] < INF)
                                    w[i][u] = min(w[i][u], w[i][v] - iw[v]);
                                w[u][i] = min(w[u][i], w[v][i]);
                                if (pre[i] == v) pre[i] = u;
                            }
                        v = pre[v];
                    } while (v != u);
                    update(u);
                    break;
                }
            if (!have_cycle) break;
        }
        for (int i = 0; i < n; i++)
            if (!removed[i]) ans += iw[i];
        return true;
    }
};
\end{lstlisting}
\subsection{LCA}
\subsubsection{倍增}
复杂度 $O((n+q) \log n)$
\begin{lstlisting}
const int maxn = 5e5 + 5;
const int maxn_log = 20;
vector<int> G[maxn];
int fa[maxn][maxn_log];  //向上走2^k步所到的结点（超过根时记为-1）
int depth[maxn];         //节点的深度
int lg[maxn];            //lg[i]的定义:log(i)+1
void dfs(int u, int pre) //dfs(root, -1);
{
    fa[u][0] = pre;
    depth[u] = depth[pre] + 1;
    for (int i = 1; (1 << i) <= depth[u]; ++i)
        fa[u][i] = fa[fa[u][i - 1]][i - 1];
    for (auto &v : G[u])
        if (v != pre)
            dfs(v, u);
}
void init(int n) //预处理，n为结点个数
{
    for (int i = 1; i <= n; ++i)
    {
        lg[i] = lg[i - 1];
        if (i == 1 << lg[i - 1])
            ++lg[i];
    }
}
int lca(int u, int v) //计算u和v的LCA
{
    if (depth[u] < depth[v])
        swap(u, v);
    while (depth[u] != depth[v])
        u = fa[u][lg[depth[u] - depth[v]] - 1];
    if (u == v)
        return u;
    for (int i = lg[depth[u]]; i >= 0; --i)
        if (fa[u][i] != fa[v][i])
            u = fa[u][i], v = fa[v][i];
    return fa[u][0];
}
\end{lstlisting}
\subsubsection{DFS+ST}
DFS+ST在线算法
时间复杂度 $O(n \log n+q)$
\begin{lstlisting}
vector<int> G[maxn], sp;
int dep[maxn], dfn[maxn];
PII dp[21][maxn << 1];
void init(int n)
{
    for (int i = 0; i < n; i++)
        G[i].clear();
    sp.clear();
}
void dfs(int u, int fa)
{
    dep[u] = dep[fa] + 1;
    dfn[u] = sp.size();
    sp.push_back(u);
    for (auto &v : G[u])
    {
        if (v == fa)
            continue;
        dfs(v, u);
        sp.push_back(u);
    }
}
void initrmq()
{
    int n = sp.size();
    for (int i = 0; i < n; i++)
        dp[0][i] = {dfn[sp[i]], sp[i]};
    for (int i = 1; (1 << i) <= n; i++)
        for (int j = 0; j + (1 << i) - 1 < n; j++)
            dp[i][j] = min(dp[i - 1][j], dp[i - 1][j + (1 << (i - 1))]);
}
int lca(int u, int v)
{
    int l = dfn[u], r = dfn[v];
    if (l > r)
        swap(l, r);
    int k = 31 - __builtin_clz(r - l + 1);
    return min(dp[k][l], dp[k][r - (1 << k) + 1]).second;
}
\end{lstlisting}
\subsubsection{Tarjan}
Tarjan离线算法
时间复杂度 $O(n+q)$
\begin{lstlisting}
int fa[maxn];          //并查集
int ans[maxn];         //存储答案
vector<int> G[maxn];   //邻接表
vector<P> query[maxn]; //存储查询信息
bool vis[maxn];        //是否被遍历
inline void init(int n)
{
    for (int i = 1; i <= n; ++i)
    {
        G[i].clear(), query[i].clear();
        fa[i] = i, vis[i] = false;
    }
}
inline void add_edge(int u, int v) { G[u].push_back(v); }
inline void add_query(int id, int u, int v)
{
    query[u].emplace_back(v, id);
    query[v].emplace_back(u, id);
}
void tarjan(int u)
{
    vis[u] = true;
    for (auto &v : G[u])
    {
        if (vis[v])
            continue;
        tarjan(v);
        unite(u, v);
    }
    for (auto &q : query[u])
    {
        int &v = q.X, &id = q.Y;
        if (!vis[v])
            continue;
        ans[id] = find(v);
    }
}
\end{lstlisting}
\subsection{Depth-First Traversal}
\subsubsection{双联通分量}
(Biconnected-Component) 双联通分量
割顶的bccno无意义
\begin{lstlisting}
int pre[maxn], iscut[maxn], bccno[maxn], dfs_clock, bcc_cnt;
vector<int> G[maxn], bcc[maxn];
stack<PII> s;
void init(int n)
{
    for (int i = 0; i < n; ++i)
        G[i].clear();
}
inline void add_edge(int u, int v) { G[u].push_back(v), G[v].push_back(u); }
int dfs(int u, int fa)
{
    int lowu = pre[u] = ++dfs_clock;
    int child = 0;
    for (auto &v : G[u])
    {
        PII e = {u, v};
        if (!pre[v]) //没有访问过v
        {
            s.push(e);
            ++child;
            int lowv = dfs(v, u);
            lowu = min(lowu, lowv); //用后代的low函数更新自己
            if (lowv >= pre[u])
            {
                iscut[u] = true;
                ++bcc_cnt;
                bcc[bcc_cnt].clear(); //注意！bcc从1开始编号
                while (true)
                {
                    PII x = s.top();
                    s.pop();
                    if (bccno[x.first] != bcc_cnt)
                        bcc[bcc_cnt].push_back(x.first), bccno[x.first] = bcc_cnt;
                    if (bccno[x.second] != bcc_cnt)
                        bcc[bcc_cnt].push_back(x.second), bccno[x.second] = bcc_cnt;
                    if (x.first == u && x.second == v)
                        break;
                }
            }
        }
        else if (pre[v] < pre[u] && v != fa)
        {
            s.push(e);
            lowu = min(lowu, pre[v]); //用反向边更新自己
        }
    }
    if (fa < 0 && child == 1)
        iscut[u] = 0;
    return lowu;
}
void find_bcc(int n) //调用结束后s保证为空，所以不用清空
{
    memset(pre, 0, sizeof(pre));
    memset(iscut, 0, sizeof(iscut));
    memset(bccno, 0, sizeof(bccno));
    dfs_clock = bcc_cnt = 0;
    for (int i = 0; i < n; ++i)
        if (!pre[i])
            dfs(i, -1);
}
\end{lstlisting}
\subsubsection{强联通分量}
强联通分量（Strongly Connected Component）
\begin{lstlisting}
vector<int> G[maxn];
int dfn[maxn];     //dfn[u]表示u在dfs时是第几个被搜到的
int lowlink[maxn]; //lowlink[u]为u及其后代中dfn最小的值
int idx[maxn];     //idx[i]为i所在的SCC编号
int id, scc_cnt;   //当前dfn编号、SCC计数器（从1开始）
stack<int> S;      //栈S保存当前SCC中的节点
inline void init(int n)
{
    for (int i = 0; i < n; i++)
        G[i].clear();
}
inline void addedge(int from, int to) { G[from].push_back(to); }
void dfs(int u)
{
    dfn[u] = lowlink[u] = ++id;
    S.push(u);
    for (auto &v : G[u])
    {
        if (!dfn[v])     //指向子节点则递归子节点后更新自己
        {
            dfs(v);
            lowlink[u] = min(lowlink[u], lowlink[v]);
        }
        else if (!idx[v]) //指向父亲（指向栈外父亲不做操作，指向栈内父亲进行更新）
            lowlink[u] = min(lowlink[u], dfn[v]);
    }
    if (lowlink[u] == dfn[u]) //当一个节点的dfn值和low值相等时，这个节点是一个强联通分量的“根”，出栈
    {
        ++scc_cnt;
        while (true)
        {
            int x = S.top();
            S.pop();
            idx[x] = scc_cnt; //sccavl[x] += ;
            if (x == u)
                break;
        }
    }
}
int tarjan(int n)
{
    id = 0, scc_cnt = 0;
    memset(idx, 0, sizeof(idx)), memset(dfn, 0, sizeof(dfn));
    for (int i = 0; i < n; ++i)
        if (!dfn[i]) //只有没访问过的点需要dfs
            dfs(i);
    return scc_cnt; //强连通分量总数
}
\end{lstlisting}
\subsubsection{2-SAT}
给一组逻辑表达式，每个表达式中恰好含两个逻辑变量，运算只包含or、not1，
求一组方案，使得所有表达式为true
复杂度：$O(n + m)$
\begin{lstlisting}
struct TwoSAT
{
    int n;
    vector<int> G[maxn << 1];
    bool mark[maxn << 1];
    int S[maxn << 1], c;
    void init(int n)
    {
        this->n = n;
        for (int i = 0; i < (n << 1); i++)
            G[i].clear();
        memset(mark, 0, sizeof(mark));
    }
    bool dfs(int x)
    {
        if (mark[x ^ 1])
            return false;
        if (mark[x])
            return true;
        mark[x] = true;
        S[c++] = x;
        for (auto &y : G[x])
            if (!dfs(y))
                return false;
        return true;
    }
    //x = xval or y = yval
    void add_clause(int x, int xval, int y, int yval)
    {
        x = (x << 1) + xval;
        y = (y << 1) + yval;
        G[x ^ 1].push_back(y);
        G[y ^ 1].push_back(x);
    }
    bool solve()
    {
        for (int i = 0; i < (n << 1); i += 2)
            if (!mark[i] && !mark[i + 1])
            {
                c = 0;
                if (!dfs(i))
                {
                    while (c > 0)
                        mark[S[--c]] = false;
                    if (!dfs(i + 1))
                        return false;
                }
            }
        return true;
    }
};
\end{lstlisting}
\subsubsection{缩点}
缩点
\begin{lstlisting}
vector<int> SCC[maxn];   //新图
int in[maxn], out[maxn]; //缩点后的入度和出度，数组下标从1开始
int sz[maxn];           //缩点后的点原先包含几个点
int sccval[maxn];        //缩点后新点的权值
void solve(int n)
{
    for (int u = 0; u < n; ++u)
    {
        ++sz[idx[u]];
        for (auto &v : G[u])
            if (idx[u] != idx[v])
            {
                ++out[idx[u]], ++in[idx[v]];
                SCC[idx[u]].push_back(idx[v]);
            }
    }
}
\end{lstlisting}
\subsubsection{割点}
\begin{lstlisting}
vector<int> G[maxn];
int dfn[maxn], lowlink[maxn];
bool vis[maxn]; //是否是割点
int id;
inline void init(int n)
{
    for (int i = 0; i < n; i++)
        G[i].clear();
}
inline void addedge(int u, int v) { G[u].push_back(v); }
void dfs(int u, int father)
{
    dfn[u] = lowlink[u] = ++id;
    int child = 0;
    for (auto &v : G[u])
    {
        if (!dfn[v])
        {
            dfs(v, u);
            lowlink[u] = min(lowlink[u], lowlink[v]);
            if (lowlink[v] >= dfn[u] && u != father)
                vis[u] = true;
            if (u == father)
                ++child;
        }
        lowlink[u] = min(lowlink[u], dfn[v]);
    }
    if (child >= 2 && u == father)
        vis[u] = true;
}
int tarjan(int n)
{
    id = 0;
    memset(dfn, 0, sizeof(dfn)), memset(vis, 0, sizeof(vis));
    for (int i = 0; i < n; ++i)
        if (!dfn[i])
            dfs(i, i);
    int res = 0;
    for (int i = 0; i < n; ++i)
        if (vis[i])
            ++res;
    return res;
}
\end{lstlisting}
\subsubsection{拓扑排序}
对一个有向无环图拓扑排序
复杂度：$O(|V| + |E|)$
\begin{lstlisting}
vector<int> G[maxn];
vector<int> ans; //拓扑排序的结果
int in[maxn];
void addedge(int u, int v) { G[u].push_back(v), ++in[v]; }
bool topo_sort(int n) //有环返回false
{
    queue<int> q; //字典序最小：优先队列
    for (int i = 0; i < n; ++i)
        if (in[i] == 0)
            q.push(i); //将所有入度为0的点入队
    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        ans.push_back(u);
        for (auto &v : G[u])
            if (--in[v] == 0) //删边的操作转化为入度减1
                q.push(v);    //如果这个点变成入度为0，入队列
    }
    return ans.size() == n;
}
\end{lstlisting}
\subsection{Eular Path}
\subsubsection{Eular Path}
如果一个图存在一笔画，则一笔画的路径叫做欧拉路，如果最后又回到起点，那这个路径叫做欧拉回路。
我们定义奇点是指跟这个点相连的边数目有奇数个的点。对于能够一笔画的图，我们有以下两个定理。
定理1：存在欧拉路的条件：图是连通的，有且只有2个奇点。
定理2：存在欧拉回路的条件：图是连通的，有0个奇点。
根据一笔画的两个定理，如果寻找欧拉回路，对任意一个点执行深度优先遍历；
找欧拉路，则对一个奇点执行dfs，时间复杂度为O(m+n)，m为边数，n是点数。
\begin{lstlisting}
int G[maxn][maxn]; //用邻接矩阵存储
int du[maxn];      //记录每个点的度，就是相连边的数目
vector<int> ans;   //记录找到的欧拉路的路径
int V;
inline void init() { memset(G, 0, sizeof(G)), memset(du, 0, sizeof(deg)); }
inline void AddEdge(int u, int v) { ++du[u], ++du[v], ++G[u][v], ++G[v][u]; }
void dfs(int s) //从度数为奇数的点深度优先遍历过程寻找欧拉路 dfs(find_start());
{
    for (int i = 0; i < V; ++i)
        if (G[s][i]) //从任意一个与它相连的点出发
        {
            --G[s][i], --G[i][s];
            dfs(i);
        }
    ans.push_back(s); //记录下路径，若顶点从1开始，输出时要加1
}
int find_start() //寻找度数为奇数的点
{
    int s = 0;                  //如果有奇点，就从奇点开始寻找，这样找到的就是
    for (int i = 0; i < V; ++i) //欧拉路。没有奇点就从任意点开始，
        if (du[i] % 2 == 1)     //这样找到的就是欧拉回路。（因为每一个点都是偶点）
        {
            s = i;
            break; //字典序最小
        }
    return s;
}
\end{lstlisting}
\subsection{Bipartite Graph Matching}
\subsubsection{Hungry(Matrix)}
\begin{lstlisting}
int uN, vN;        //uN是匹配左边的顶点数,vN是匹配右边的顶点数
int g[maxn][maxn]; //邻接矩阵g[i][j] = 1表示i->j的有向边就可以了,是左边向右边的匹配
int linker[maxn];
bool vis[maxn];
bool dfs(int u)
{
    for (int v = 0; v < vN; ++v)
        if (g[u][v] && !vis[v])
        {
            vis[v] = true;
            if (linker[v] == -1 || dfs(linker[v]))
            {
                linker[v] = u;
                return true;
            }
        }
    return false;
}
int hungary(int uN)
{
    int res = 0;
    memset(linker, -1, sizeof(linker));
    for (int u = 0; u < uN; ++u)
    {
        memset(vis, 0, sizeof(vis));
        if (dfs(u))
            ++res;
    }
    return res;
}
\end{lstlisting}
\subsubsection{Hungry(List)}
一般地，可行性+唯一性的匹配问题可用二分图解
O(nm)
\begin{lstlisting}
int uN, vN; //左边顶点数、右边顶点数 u → v
vector<int> G[max_u];
//调用hungary算法后，表示右边顶点v与左边顶点linker[v]相连
//linker[v]=-1表示没有点与v相连
int linker[max_v];
bool vis[max_v];
inline void addedge(int u, int v) //u → v（二分图只需调用一次，从左边顶点连向右边顶点）
{
    G[u].push_back(v);
}
bool dfs(int u)
{
    for (auto &v : G[u])
    {
        if (!vis[v])
        {
            vis[v] = true;
            if (linker[v] == -1 || dfs(linker[v]))
            {
                linker[v] = u;
                return true;
            }
        }
    }
    return false;
}
int hungary(int uN)
{
    int res = 0;
    memset(linker, -1, sizeof(linker));
    for (int u = 0; u < uN; ++u)
    {
        memset(vis, false, sizeof(vis));
        if (dfs(u))
            ++res;
    }
    return res;
}
\end{lstlisting}
\subsubsection{Hopcroft-Carp}
复杂度 O(sqrt(n)*E)
\begin{lstlisting}
vector<int> G[maxn];
int uN, dis; // uN为左端的顶点数,使用前赋值(点编号0开始)
int Mx[maxn], My[maxn];
int dx[maxn], dy[maxn];
bool used[maxn];
inline void init(int n)
{
    for (int i = 0; i < n; i++)
        G[i].clear();
}
inline void addedge(int u, int v) { G[u].push_back(v); }
bool bfs()
{
    queue<int> q;
    dis = INF;
    memset(dx, -1, sizeof(dx)), memset(dy, -1, sizeof(dy));
    for (int i = 0; i < uN; i++)
        if (Mx[i] == -1)
            q.push(i), dx[i] = 0;
    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        if (dx[u] > dis)
            break;
        for (auto &v : G[u])
        {
            if (dy[v] == -1)
            {
                dy[v] = dx[u] + 1;
                if (My[v] == -1)
                    dis = dy[v];
                else
                {
                    dx[My[v]] = dy[v] + 1;
                    q.push(My[v]);
                }
            }
        }
    }
    return dis != INF;
}
bool dfs(int u)
{
    for (auto &v : G[u])
    {
        if (!used[v] && dy[v] == dx[u] + 1)
        {
            used[v] = true;
            if (My[v] != -1 && dy[v] == dis)
                continue;
            if (My[v] == -1 || dfs(My[v]))
            {
                My[v] = u, Mx[u] = v;
                return true;
            }
        }
    }
    return false;
}
int MaxMatch()
{
    int res = 0;
    memset(Mx, -1, sizeof(Mx)), memset(My, -1, sizeof(My));
    while (bfs())
    {
        memset(used, 0, sizeof(used));
        for (int i = 0; i < uN; i++)
            if (Mx[i] == -1 && dfs(i))
                ++res;
    }
    return res;
}
\end{lstlisting}
\subsubsection{Hungry(Multiple)}
\begin{lstlisting}
int uN, vN;        //u,v的数目,使用前面必须赋值
int g[maxn][maxm]; //邻接矩阵
int linker[maxm][maxn];
bool used[maxm];
int num[maxm]; //右边最大的匹配数
bool dfs(int u)
{
    for (int v = 0; v < vN; v++)
        if (g[u][v] && !used[v])
        {
            used[v] = true;
            if (linker[v][0] < num[v])
            {
                linker[v][++linker[v][0]] = u;
                return true;
            }
            for (int i = 1; i <= num[0]; i++)
                if (dfs(linker[v][i]))
                {
                    linker[v][i] = u;
                    return true;
                }
        }
    return false;
}
int hungary()
{
    int res = 0;
    for (int i = 0; i < vN; ++i)
        linker[i][0] = 0;
    for (int u = 0; u < uN; ++u)
    {
        memset(used, 0, sizeof(used));
        if (dfs(u))
            ++res;
    }
    return res;
}
\end{lstlisting}
\subsubsection{KM算法}
Kuhn-Munkres
给定一个带权的二分图，求权值最大的完备匹配
复杂度：$O(n^3)$
\begin{lstlisting}
int n;
int cost[maxn][maxn];
int lx[maxn], ly[maxn], match[maxn], slack[maxn];
int pre[maxn];
bool vy[maxn];
void augment(int root)
{
    fill(vy + 1, vy + n + 1, false);
    fill(slack + 1, slack + n + 1, INF);
    int py;
    match[py = 0] = root;
    do
    {
        vy[py] = true;
        int x = match[py], yy;
        int delta = INF;
        for (int y = 1; y <= n; ++y)
        {
            if (!vy[y])
            {
                if (lx[x] + ly[y] - cost[x][y] < slack[y])
                    slack[y] = lx[x] + ly[y] - cost[x][y], pre[y] = py;
                if (slack[y] < delta)
                    delta = slack[y], yy = y;
            }
        }
        for (int y = 0; y <= n; ++y)
        {
            if (vy[y])
                lx[match[y]] -= delta, ly[y] += delta;
            else
                slack[y] -= delta;
        }
        py = yy;
    } while (match[py] != -1);
    do
    {
        int temp = pre[py];
        match[py] = match[temp], py = temp;
    } while (py);
}
int KM()
{
    for (int i = 1; i <= n; ++i)
    {
        lx[i] = ly[i] = 0;
        match[i] = -1;
        for (int j = 1; j <= n; ++j)
            lx[i] = max(lx[i], cost[i][j]);
    }
    int res = 0;
    for (int root = 1; root <= n; ++root)
        augment(root);
    for (int i = 1; i <= n; ++i)
        res += lx[i], res += ly[i];
    return res;
}
\end{lstlisting}
\subsubsection{二分图判定}
二分图判定 —— 染色法
定理：无向图是二分图 <=> 图中无奇环（长度为奇数的环）
因为每一条边都是从一个集合走到另一个集合，只有走偶数次才可能回到同一个集合。
\begin{lstlisting}
vector<int> G[max_v];
int col[max_v];        //顶点i的颜色（1 or -1）
bool dfs(int u, int c) //把顶点染成1或-1
{
    col[u] = c; //把顶点v染成颜色c
    for (auto &v : G[u])
    {
        if (col[v] == c) //如果相邻的顶点同色，则返回false
            return false;
        if (!col[v] && !dfs(v, -c)) //如果相邻的顶点还没被染色，则染成-c
            return false;
    }
    return true; //如果所有顶点都染过色了，则返回true
}
bool check(int n)
{
    memset(col, 0, sizeof(col));
    for (int i = 0; i < n; ++i)
        if (!col[i] && !dfs(i, 1))
            return false;
    return true;
}
\end{lstlisting}
\subsection{Network Flows}
\subsubsection{Dinic}
\begin{lstlisting}
struct Edge
{
    int from, to, cap, flow;
    Edge(int u, int v, int c, int f) : from(u), to(v), cap(c), flow(f) {}
};
struct Dinic
{
    int n, m, s, t;       //结点数，边数（包括反向弧），源点编号和汇点编号
    vector<Edge> edges;   //边表。edge[e]和edge[e^1]互为反向弧
    vector<int> G[max_v]; //邻接表，G[i][j]表示节点i的第j条边在e数组中的序号
    bool vis[max_v];      //BFS使用
    int d[max_v];         //从起点到i的距离
    int cur[max_v];       //当前弧下标
    void init(int V)
    {
        this->n = V;
        for (int i = 0; i < n; i++)
            G[i].clear();
        edges.clear();
    }
    void addedge(int from, int to, int cap)
    {
        edges.emplace_back(from, to, cap, 0);
        edges.emplace_back(to, from, 0, 0);
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }
    bool bfs()
    {
        memset(vis, false, sizeof(vis)), memset(d, 0, sizeof(d));
        queue<int> q;
        q.push(s);
        d[s] = 0, vis[s] = true;
        while (!q.empty())
        {
            int x = q.front();
            q.pop();
            for (auto &id : G[x])
            {
                Edge &e = edges[id];
                if (!vis[e.to] && e.cap > e.flow)
                {
                    vis[e.to] = true;
                    d[e.to] = d[x] + 1;
                    q.push(e.to);
                }
            }
        }
        return vis[t];
    }
    int dfs(int x, int a)
    {
        if (x == t || a == 0)
            return a;
        int flow = 0, f;
        for (int &i = cur[x]; i < G[x].size(); ++i) //从上次考虑的弧
        {
            Edge &e = edges[G[x][i]];
            if (d[x] + 1 == d[e.to] && (f = dfs(e.to, min(a, e.cap - e.flow))) > 0)
            {
                e.flow += f;
                edges[G[x][i] ^ 1].flow -= f;
                flow += f;
                a -= f;
                if (a == 0)
                    break;
            }
        }
        return flow;
    }
    int max_flow(int s, int t)
    {
        this->s = s, this->t = t;
        int flow = 0;
        while (bfs())
        {
            memset(cur, 0, sizeof(cur));
            flow += dfs(s, INF);
        }
        return flow;
    }
};
\end{lstlisting}
\subsubsection{MinCost MaxFlow}
\begin{lstlisting}
struct Edge
{
    int from, to, cap, flow, cost;
    Edge(int u, int v, int c, int f, int w) : from(u), to(v), cap(c), flow(f), cost(w) {}
};
struct MCMF
{
    int n, m;
    vector<Edge> edges;
    vector<int> G[max_v];
    int inq[max_v]; //是否在队列中
    int d[max_v];   //最小花费
    int p[max_v];   //上一条弧
    int a[max_v];   //可改进量
    void init(int V)
    {
        this->n = V;
        for (int i = 0; i < n; i++)
            G[i].clear();
        edges.clear();
    }
    void AddEdge(int from, int to, int cap, int cost)
    {
        edges.emplace_back(from, to, cap, 0, cost);
        edges.emplace_back(to, from, 0, 0, -cost);
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }
    bool BellmanFord(int s, int t, int &flow, ll &cost)
    {
        for (int i = 0; i < n; i++)
            d[i] = INF;
        memset(inq, 0, sizeof(inq));
        queue<int> q;
        q.push(s);
        d[s] = 0, inq[s] = 1, p[s] = 0, a[s] = INF;
        while (!q.empty())
        {
            int u = q.front();
            q.pop();
            inq[u] = 0;
            for (int i = 0; i < G[u].size(); i++)
            {
                Edge &e = edges[G[u][i]];
                if (e.cap > e.flow && d[e.to] > d[u] + e.cost)
                {
                    d[e.to] = d[u] + e.cost;
                    p[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if (!inq[e.to])
                    {
                        q.push(e.to);
                        inq[e.to] = 1;
                    }
                }
            }
        }
        if (d[t] == INF)
            return false; // 当没有可增广的路时退出
        flow += a[t];
        cost += (ll)d[t] * (ll)a[t];
        for (int u = t; u != s; u = edges[p[u]].from)
        {
            edges[p[u]].flow += a[t];
            edges[p[u] ^ 1].flow -= a[t];
        }
        return true;
    }
    int MincostMaxflow(int s, int t, ll &cost)
    {
        int flow = 0;
        cost = 0;
        while (BellmanFord(s, t, flow, cost))
            ;
        return flow;
    }
};
\end{lstlisting}
\clearpage\section{Computational Geometry}
\subsection{Basic Function}
\begin{lstlisting}
const double eps = 1e-8;
#define zero(x) ((fabs(x) < eps ? 1 : 0))
#define sgn(x) (fabs(x) < eps ? 0 : ((x) < 0 ? -1 : 1))
struct point
{
    double x, y;
    point(double a = 0, double b = 0) { x = a, y = b; }
    point operator-(const point &b) const { return point(x - b.x, y - b.y); }
    point operator+(const point &b) const { return point(x + b.x, y + b.y); }
    point operator/(const double &k) const { return point(x / k, y / k); }
    // 两点是否重合
    bool operator==(point &b) { return zero(x - b.x) && zero(y - b.y); }
    // 点积(以原点为基准)
    // 用于判断两个向量是否垂直或共线
    double operator*(const point &b) const { return x * b.x + y * b.y; }
    // 叉积(以原点为基准)
    // 用于判断两个向量之间的相对位置（顺时针还是逆时针）
    // 叉积的值为两个向量形成的三角形的有向面积
    double operator^(const point &b) const { return x * b.y - y * b.x; }
    // 绕P点逆时针旋转a弧度后的点
    point rotate(point b, double a)
    {
        double dx, dy;
        (*this - b).split(dx, dy);
        double tx = dx * cos(a) - dy * sin(a);
        double ty = dx * sin(a) + dy * cos(a);
        return point(tx, ty) + b;
    }
    // 点坐标分别赋值到a和b
    void split(double &a, double &b) { a = x, b = y; }
    // 极角排序
    point base() const
    {
        if (x < 0 || (x == 0 && y < 0))
            return point(-x, -y);
        return *this;
    }
    bool operator<(const point &b) const
    {
        point p1 = base(), p2 = b.base();
        return (p1 ^ p2) > 0;
    }
};
struct line
{
    point s, e;
    line() {}
    line(point ss, point ee) { s = ss, e = ee; }
};
\end{lstlisting}
\subsection{Position}
\subsubsection{两点间距离}
\begin{lstlisting}
double dist(point a, point b) { return sqrt((a - b) * (a - b)); }
\end{lstlisting}
\subsubsection{两直线位置关系}
$<0, *>$ 表示重合
$<1, *>$ 表示平行
$<2, P>$ 表示交点是 $P$
\begin{lstlisting}
pair<int, point> spoint(line l1, line l2)
{
    point res = l1.s;
    if (sgn((l1.s - l1.e) ^ (l2.s - l2.e)) == 0)               //首先用叉积判断是否平行
        return {sgn((l1.s - l2.e) ^ (l2.s - l2.e)) != 0, res}; //若平行，再用叉积判断是否重合
    //若不平行则必定相交，用相似三角形求出交点
    double t = ((l1.s - l2.s) ^ (l2.s - l2.e)) / ((l1.s - l1.e) ^ (l2.s - l2.e));
    res.x += (l1.e.x - l1.s.x) * t;
    res.y += (l1.e.y - l1.s.y) * t;
    return {2, res};
}
\end{lstlisting}
\subsubsection{线段是否相交}
+ 快速排除实验

对于两个线段作出正矩形，若矩形不相交，那么线段一定不相交。
即使两个矩形相交，这两条线段也不一定相交
+ 跨立实验

跨立：如果点 $P_1$ 处于直线 $P_3P_4$ 的一边，而 $P_2$ 处于该直线的另一边，则我们说线段 $P_1P_2$ 跨立直线 $P_3P_4$，如果 $P_1$ 或 $P_2$ 在直线 $P_3P_4$ 上，也算跨立
两条线段相交当且仅当它们能够通过快速排除试验，并且每一条线段都跨立另一条线段所在的直线。
只需检查叉积 $(P3-P1)\times(P2-P1)$ 与 $(P4-P1)\times(P2-P1)$ 的符号是否异号，若异号则跨立

规范相交：两条线段只有一个非端点的交点 <号
不规范相交 <=号

\begin{lstlisting}
bool segxseg(line l1, line l2)
{
    return max(l1.s.x, l1.e.x) >= min(l2.s.x, l2.e.x) &&
           max(l2.s.x, l2.e.x) >= min(l1.s.x, l1.e.x) &&
           max(l1.s.y, l1.e.y) >= min(l2.s.y, l2.e.y) &&
           max(l2.s.y, l2.e.y) >= min(l1.s.y, l1.e.y) &&
           sgn((l2.s - l1.e) ^ (l1.s - l1.e)) * sgn((l2.e - l1.e) ^ (l1.s - l1.e)) <= 0 &&
           sgn((l1.s - l2.e) ^ (l2.s - l2.e)) * sgn((l1.e - l2.e) ^ (l2.s - l2.e)) <= 0;
}
\end{lstlisting}
\subsubsection{直线与线段是否相交}
l1是直线,l2是线段
\begin{lstlisting}
bool segxline(line l1, line l2)
{
    return sgn((l2.s - l1.e) ^ (l1.s - l1.e)) * sgn((l2.e - l1.e) ^ (l1.s - l1.e)) <= 0;
}
\end{lstlisting}
\subsubsection{点到直线距离}
\begin{lstlisting}
double pointtoline(point p, line l)
{
    point res;
    double t = ((p - l.s) * (l.e - l.s)) / ((l.e - l.s) * (l.e - l.s));
    res.x = l.s.x + (l.e.x - l.s.x) * t, res.y = l.s.y + (l.e.y - l.s.y) * t;
    return dist(p, res);
}
\end{lstlisting}
\subsubsection{点到线段距离}
\begin{lstlisting}
double pointtosegment(point p, line l)
{
    point res;
    double t = ((p - l.s) * (l.e - l.s)) / ((l.e - l.s) * (l.e - l.s));
    if (t >= 0 && t <= 1)
        res.x = l.s.x + (l.e.x - l.s.x) * t, res.y = l.s.y + (l.e.y - l.s.y) * t;
    else
        res = dist(p, l.s) < dist(p, l.e) ? l.s : l.e;
    return dist(p, res);
}
\end{lstlisting}
\subsubsection{点是否在线段上}
\begin{lstlisting}
bool PointOnSeg(point p, line l)
{
    return
        sgn((l.s - p) ^ (l.e-p)) == 0 &&
        sgn((p.x - l.s.x) * (p.x - l.e.x)) <= 0 &&
        sgn((p.y - l.s.y) * (p.y - l.e.y)) <= 0;
}
\end{lstlisting}
\subsection{Polygon}
\subsubsection{Area}
\begin{lstlisting}
double area(point p[], int n)
{
    double res = 0;
    for (int i = 0; i < n; ++i)
        res += p[i] ^ p[(i + 1) % n];
    return fabs(res / 2);
}
\end{lstlisting}
\subsubsection{点和凸多边形的位置关系}
Point in Convex
点形成一个凸包, 而且按逆时针排序(如果是顺时针把里面的<0改为>0)
点的编号 : [0,n)
-1 : 点在凸多边形外
0  : 点在凸多边形边界上
1  : 点在凸多边形内
\begin{lstlisting}
int PointInConvex(point a, point p[], int n)
{
    for (int i = 0; i < n; i++)
        if (sgn((p[i] - a) ^ (p[(i + 1) % n] - a)) < 0)
            return -1;
        else if (PointOnSeg(a, line(p[i], p[(i + 1) % n])))
            return 0;
    return 1;
}
\end{lstlisting}
\subsubsection{点和多边形的位置关系}
Point in Polygon
射线法,poly[]的顶点数要大于等于3,点的编号0~n-1
-1 : 点在多边形外
0  : 点在多边形边界上
1  : 点在多边形内
\begin{lstlisting}
int PointInPoly(point p, point poly[], int n)
{
    int cnt;
    line ray, side;
    cnt = 0;
    ray.s = p;
    ray.e.y = p.y;
    ray.e.x = -100000000000.0; // -INF,注意取值防止越界
    for (int i = 0; i < n; i++)
    {
        side.s = poly[i], side.e = poly[(i + 1) % n];
        if (PointOnSeg(p, side)) return 0;
        //如果平行轴则不考虑
        if (sgn(side.s.y - side.e.y) == 0)
            continue;
        if (PointOnSeg(side.s, ray))
            cnt += (sgn(side.s.y - side.e.y) > 0);
        else if (PointOnSeg(side.e, ray))
            cnt += (sgn(side.e.y - side.s.y) > 0);
        else if (segxseg(ray, side))
            cnt++;
    }
    return cnt % 2 == 1 ? 1 : -1;
}
\end{lstlisting}
\subsubsection{Judge Convex}
点可以是顺时针给出也可以是逆时针给出
点的编号1~n-1
\begin{lstlisting}
bool isconvex(point poly[], int n)
{
    bool s[3];
    memset(s, 0, sizeof(s));
    for (int i = 0; i < n; i++)
    {
        s[sgn((poly[(i + 1) % n] - poly[i]) ^ (poly[(i + 2) % n] - poly[i])) + 1] = 1;
        if (s[0] && s[2]) return 0;
    }
    return 1;
}
\end{lstlisting}
\subsection{Integer Points}
\subsubsection{On Segment}
\begin{lstlisting}
int OnSegment(line l) { return __gcd(fabs(l.s.x - l.e.x), fabs(l.s.y - l.e.y)) + 1; }
\end{lstlisting}
\subsubsection{On Polygon Edge}
\begin{lstlisting}
int OnEdge(point p[], int n)
{
    int i, ret = 0;
    for (i = 0; i < n; i++)
        ret += __gcd(fabs(p[i].x - p[(i + 1) % n].x), fabs(p[i].y - p[(i + 1) % n].y));
    return ret;
}
\end{lstlisting}
\subsubsection{Inside Polygon}
\begin{lstlisting}
int InSide(point p[], int n)
{
    int i, area = 0;
    for (i = 0; i < n; i++)
        area += p[(i + 1) % n].y * (p[i].x - p[(i + 2) % n].x);
    return (fabs(area) - OnEdge(p, n)) / 2 + 1;
}
\end{lstlisting}
\subsection{Circle}
\subsubsection{Circumcenter}
\begin{lstlisting}
point waixin(point a, point b, point c)
{
    double a1 = b.x - a.x, b1 = b.y - a.y, c1 = (a1 * a1 + b1 * b1) / 2;
    double a2 = c.x - a.x, b2 = c.y - a.y, c2 = (a2 * a2 + b2 * b2) / 2;
    double d = a1 * b2 - a2 * b1;
    return point(a.x + (c1 * b2 - c2 * b1) / d, a.y + (a1 * c2 - a2 * c1) / d);
}
\end{lstlisting}
\clearpage\section{Dynamic Programming}
\subsection{LCS}
\subsubsection{LCS字符串}
最长公共子串（Longest Common Substirng）和最长公共子序列（Longest Common Subsequence，LCS）的区别为：
子串是串的一个连续的部分，子序列则是从不改变序列的顺序，而从序列中去掉任意的元素而获得新的序列；
也就是说，子串中字符的位置必须是连续的，子序列则可以不必连续。
\begin{lstlisting}
int dp[maxn][maxn];
int LCS(const string &x, const string &y)
{
    memset(dp, 0, sizeof(dp));
    int n = x.length(), m = y.length();
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < m; ++j)
            if (x[i] == y[j])
                dp[i + 1][j + 1] = dp[i][j] + 1;
            else
                dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]);
    return dp[n][m];
}
\end{lstlisting}
\subsubsection{LCS整数}
给出1~n的两个排列P1和P2，求它们的最长公共子序列。
\begin{lstlisting}
int a[maxn], b[maxn], idx[maxn];
int dp[maxn];
int n;

cin >> a[i];
idx[a[i]] = i;

cin >> b[i];
b[i] = idx[b[i]];
\end{lstlisting}
\subsection{LIS和LDS}
\subsubsection{LIS和LDS}
\begin{lstlisting}
int a[maxn], lis[maxn], lds[maxn];
int LIS(int n) //返回最长上升子序列长度，序列存在lis[]中（序列下标从1开始）
{
    int len = 1;                 //最长不上升子序列（逆序）
    lis[1] = a[1];               //lds[n] = a[n];
    for (int i = 2; i <= n; ++i) //for (int i = n; i >= 1; --i)
        if (lis[len] <= a[i])
            lis[++len] = a[i];
        else
            *lower_bound(lis + 1, lis + 1 + len, a[i]) = a[i];
    return len;
}
\end{lstlisting}
简单写法(下标从0开始,只返回长度)
\begin{lstlisting}
int dp[maxn];
int LIS(int n) //返回最长不下降子序列的长度
{
    memset(dp, 0x3f, sizeof(dp)); //返回最长不上升子序列的长度：
    for (int i = 0; i < n; ++i)   //for (int i = n - 1; i >= 0; --i)
        *lower_bound(dp, dp + n, a[i]) = a[i];
    return lower_bound(dp, dp + n, INF) - dp;
}
\end{lstlisting}
\subsubsection{最大上升子序列和}
对于给定的序列，求出最大上升子序列和。注意，最长的上升子序列的和不一定是最大的
\begin{lstlisting}
int a[maxn], dp[maxn];
int solve()
{
    int res = -1;
    for (int i = 1; i <= n; i++)
    {
        dp[i] = a[i];
        for (int j = 1; j < i; j++)
            if (a[j] < a[i] && dp[j] + a[i] > dp[i])
                dp[i] = dp[j] + a[i];
        res = max(res, dp[i]);
    }
    return res;
}
\end{lstlisting}
\subsection{背包}
\subsubsection{有依赖的背包问题}
\begin{lstlisting}
int n, m;                       //物品种数、容量
int w[maxn], v[maxn], dp[maxm]; //weight、value
int W[maxn][maxn], V[maxn][maxn];
int cnt[maxn], id[maxn][maxn]; //组合背包：cnt[k]记录第k组共有几件物品，id[k][i]记录第k组第i件物品的序号
int cnt2[maxn];
int main()
{
    cin >> m >> n;
    int num = 0; //num记录组的总数
    for (int i = 1; i <= n; ++i)
    {
        int temp, k; //k为小组编号
        cin >> w[i] >> temp >> k;
        v[i] = w[i] * temp;
        if (k == 0)
            ++num, id[i][0] = i; //第k组的主件序号
        else
            ++cnt[k], id[k][cnt[k]] = i;
    }
    for (int k = 1; k <= n; ++k) //01背包处理
    {
        if (id[k][0]) //如果当前物品为主件
        {
            memset(dp, -1, sizeof(dp)); //恰好背包的处理，-1表示不恰好取到此价值
            dp[0] = 0;                  //恰好背包的处理
            for (int i = 1; i <= cnt[k]; ++i)
            {
                int temp = id[k][i];
                for (int j = m - w[id[k][0]]; j >= w[temp]; --j)
                    if (dp[j - w[temp]] != -1) //恰好背包的判断
                        dp[j] = max(dp[j], dp[j - w[temp]] + v[temp]);
            }
            for (int j = 0; j <= m - w[id[k][0]]; ++j)
                if (dp[j] != -1) //恰好背包的判断，这种附件组合满足题意
                {
                    ++cnt2[k];
                    W[k][cnt2[k]] = j + w[id[k][0]];
                    V[k][cnt2[k]] = dp[j] + v[id[k][0]]; //把此情况存在主件k的分组中，为分组背包做好处理
                }
            //只买主件
            ++cnt2[k];
            W[k][cnt2[k]] = w[id[k][0]];
            V[k][cnt2[k]] = v[id[k][0]];
        }
    }
    memset(dp, 0, sizeof(dp));
    for (int k = 1; k <= n; ++k)               //枚举k个组
        for (int j = m; j >= 0; --j)           //枚举容量
            for (int i = 1; i <= cnt2[k]; ++i) //枚举各组中物品的序号
                if (j >= W[k][i])
                    dp[j] = max(dp[j], dp[j - W[k][i]] + V[k][i]);
    cout << dp[m] << endl;
    return 0;
}
\end{lstlisting}
\subsection{数位DP}
\subsubsection{数位DP}
state:状态变量，状态初始值要使最高位满足题目的约束条件
state可表示pos前一位数字(10)、前pos位数字之和(位数*9)、某个数字在前pos位出现的次数(位数)
数位DP中如果条件中有余数或整除的情况，都可以把余数作为dp的其中一个状态，以节省空间
lead:前导零、limit:数位上界变量
\begin{lstlisting}
int a[20];
ll dp[20][state]; //根据不同的题目，state的取值范围不同
ll dfs(int pos, int state, bool lead, bool limit)
{
    if (pos == -1) //递归边界，从最高位按位枚举，最低位是0，pos==-1说明这个数枚举完了
        return 1;  //返回1，表示枚举的这个数是合法的
    if (!limit && !lead && dp[pos][state] != -1)
        return dp[pos][state];
    int up = limit ? a[pos] : 9; //根据limit判断枚举的上界up：前一位是0时，上界为9；前一位不为0时，上界为a[pos]
    ll res = 0;
    //枚举过程中不能改变state的值
    for (int i = 0; i <= up; ++i) //枚举，然后把不同情况的个数加到ans就可以了
    {
        if (i == 0 && lead) //前导零
            res += dfs(pos - 1, /*状态初始值*/, lead && i == 0, limit && i == up);
        else if () //根据题目的约束条件分类讨论
            res += dfs(pos - 1, /*状态转移*/, lead && i == 0, limit && i == up);
    }
    if (!limit && !lead) //计算完，记录状态
        dp[pos][state] = res;
    return res;
}
ll solve(ll x)
{
    int pos = 0;
    do //把数位都分解出来
        a[pos++] = x % 10;
    while (x /= 10);
    return dfs(pos - 1, /*状态初始值*/, true, true); //从最高位开始枚举，刚开始最高位都是有限制并且有前导零的，显然比最高位还要高的一位视为0
}

ll x, y;                    //注意是long long类型
memset(dp, -1, sizeof(dp)); //只需初始化一次，放在solve函数中会超时，此时需要注意state变量的定义
cout << solve(y) - solve(x - 1) << endl;
\end{lstlisting}
\clearpage\section{Others}
\subsection{MaxSeqMatix}
\begin{lstlisting}
int mat[10][10], s[10];       //输入矩阵和辅助数组
int n, m;                     //矩阵的行、列
int MaxSeqSum(int a[], int n) //序列a和长度n，最大子段和
{
    int sum = 0, cur = 0;
    for (int i = 0; i < n; ++i)
        cur += a[i], sum = max(cur, sum), cur = max(0, cur);
    return sum;
}
int MaxSeqMatix() //最大子矩阵
{
    int res = 0;
    for (int i = 0; i < n; ++i)
    {
        memset(s, 0, sizeof(s));
        for (int j = i; j < n; ++j)
        {
            for (int k = 0; k < m; ++k)
                s[k] += mat[j][k];
            res = max(MaxSeqSum(s, m), res);
        }
    }
    return res;
}
\end{lstlisting}
\subsection{区间调度问题}
有n项工作，每项工作分别在si时间开始，在ti时间结束。最多能参与多少项工作？
\begin{lstlisting}
pair<int, int> a[maxn];

for (int i = 0; i < n; i++)
    cin >> a[i].second >> a[i].first;
sort(a, a + n); //先根据first排序，fisrt相同的再根据second排序
int cnt = 0, temp = 0;
for (int i = 0; i < n; i++)
{
    if (temp < a[i].second) //若区间可以重合则为小于等于
    {
        ++cnt;
        temp = a[i].first;
    }
}
\end{lstlisting}
\subsection{连通分量}
\begin{lstlisting}
char mat[maxn][maxn]; //矩阵
int n, m;             //边界
int idx[maxn][maxn];
int f[maxn * maxn];                                 //映射查找数组
int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; //东南西北方向对应于行数i和列数j的变化
int cnt;                                            //cnt为每个连通块包含的格子个数
inline bool check(int a, int b) { return 0 <= a && a < n && 0 <= b && b < m; }
void dfs(int a, int b, int id, char ch)
{
    idx[a][b] = id;
    for (int i = 0; i < 4; ++i)
    {
        int c = a + dir[i][0], d = b + dir[i][1];
        if (check(c, d) && idx[c][d] == 0 && mat[c][d] == ch) //未出界的格子、未访问过的格子
            dfs(c, d, id, ch);
    }
    ++cnt;
}
int solve(char ch) //返回连通块的数量
{
    memset(idx, 0, sizeof(idx));
    int id = 0; //id为连通分量编号，从1开始，同一个连通块的格子的编号相同
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < m; ++j)
            if (idx[i][j] == 0 && mat[i][j] == ch)
            {
                cnt = 0;
                dfs(i, j, ++id, ch);
                f[idx[i][j]] = cnt;
            }
    return id; //最终id数即为连通块的数量
}
\end{lstlisting}
\subsection{Fast Scanner}
适用于正负整数
\begin{lstlisting}
template <class T>
inline bool input(T &res)
{
    char c;
    int sgn;
    if (c = getchar(), c == EOF)
        return false; //EOF
    while (c != '-' && (c < '0' || c > '9'))
        c = getchar();
    sgn = (c == '-') ? -1 : 1;
    res = (c == '-') ? 0 : (c - '0');
    while (c = getchar(), c >= '0' && c <= '9')
        res = res * 10 + (c - '0');
    res *= sgn;
    return true;
}
template <class T>
inline void output(T x)
{
    if (x < 0)
        x = -x, putchar('-');
    if (x > 9)
        output(x / 10);
    putchar(x % 10 + '0');
}
\end{lstlisting}

\end{document}
